<h1>6</h1>
<hr/><h1>Bridge Requirements for Managing Faces</h1><p>The majority of the Bridge&rsquo;s control function is implemented by overriding various Faces extension points to translate between the corresponding Faces function and the Portlet model.</p><a id="a-name61"></a><h2><a name="6.1"></a>6.1 ExternalContext</h2><p>The Faces <code>ExternalContext</code> provides the container independent abstraction of the request and response to the Faces runtime environment. By implementing an <code>ExternalContext</code>, the portlet bridge provides access to the portlet request and response.</p><p>The <code>ExternalContext</code> is acquired from the <code>FacesContext</code>. To provide an <code>ExternalContext</code> implementation the bridge must provide a <code>FacesContext</code> implementation. A <code>FacesContext</code> is manufactured via a FacesContextFactory [Section 6.5 of JSF 1.2 Specification]. The bridge must use the Faces <code>FactoryFinder</code> to acquire the <code>FacesContextFactory</code> which it then uses to instantiate and acquire a <code>FacesContext</code>.</p><a id="a-name611"></a><h3><a name="6.1.1"></a>6.1.1 FacesContextFactory</h3><p>The bridge provides an implementation of <code>FacesContextFactory</code> in order to expose its <code>ExternalContext</code>. This <code>FacesContextFactory</code> must be configured as a service provider in the <code>META-INF/services</code> directory of the Java jar file containing the bridge implementation:</p><p>The file <code>META-INF/services/javax.faces.context.FacesContextFactory</code> contains the name of the bridge&rsquo;s concrete <code>FacesContextFactory</code> implementation class<sup>[<a href="TCK-Tests.html#6.1">6.1</a>]</sup>.</p><p>The bridge&rsquo;s implementation of the <code>FacesContextFactory</code> must follow the decorator design pattern such that there is a constructor with a single argument of type <code>FacesContextFactory</code> so that the custom implementation receives a reference to the implementation that was previously fulfilling the role. In this way, the custom implementation is able to override just a subset of the functionality (or provide only some additional functionality) and delegate the rest to the existing implementation.</p><p>In implementing the <code>getFacesContext</code> method, the bridge must provide its own instance of the <code>FacesContext</code> without delegating if and only if the request is being serviced by a portlet in the portlet container. Otherwise the bridge must delegate to the previous factory and perform no other action.</p><p>The bridge must not assume that the <code>FacesContext</code> returned by calling <code>getFacesContext</code> is an <em>instanceof</em> its <code>FacesContext</code> implementation class<sup>[<a href="TCK-Tests.html#6.2">6.2</a>]</sup>. Other Faces subsystems running in the portlet bridge environment are free to introduce their own factory and wrapping implementation as long as they follow the decorator pattern described above.</p><a id="a-name612"></a><h3><a name="6.1.2"></a>6.1.2 FacesContext</h3><p><code>FacesContext</code> contains all of the per-request state information related to the processing of a single Faces request and the rendering of the corresponding response. It is passed to, and potentially modified by, each phase of the request processing lifecycle.</p><p>A <code>FacesContext</code> instance is associated with a particular request at the beginning of request processing, by a call to the <code>getFacesContext()</code> method of the <code>FacesContextFactory</code> instance associated with the current web application. The instance remains active until its <code>release()</code> method is called, after which no further references to this instance are allowed. While a <code>FacesContext</code> instance is active, it must not be referenced from any thread other than the one upon which the servlet container executing this web application utilizes for the processing of this request<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>.</p><p>Because there are subtle differences between the servlet and portlet models, its recommended that the bridge&rsquo;s <code>FacesContext</code> implementation not delegate any method implementations. For each method implemented by the bridge&rsquo;s <code>FacesContext</code>, the implementation must meet all the requirements for that method as defined in the JSF 1.2 specification.</p><p>In addition, the bridge&rsquo;s <code>FacesContext</code> is required to do the following:</p>
<ul>
  <li><code>setViewRoot()</code>:</li>
</ul><p>If the class of the <code>UIViewRoot</code> passed to <code>setViewRoot</code> is annotated with <code>javax.portlet.faces.annotation.PortletNamingContainer</code> then it additionally must set the <code>&quot;X-JAVAX-PORTLET-FACES-NAMESPACED-RESPONSE&quot;</code> portlet response property with a String value of <code>&quot;true&quot;</code>. For further explanation see section <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.6">6.6</a>.</p><a id="a-name613"></a><h3><a name="6.1.3"></a>6.1.3 ExternalContext Methods</h3><p>The Faces 1.2 <code>ExternalContext</code>javadoc describes specific behaviors for each method executed in the portlet request context. By and large these descriptions are complete and accurate. Section <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.1.3.2">6.1.3.2</a> provides these descriptions. However, a few methods aren&rsquo;t adequately described or are incorrect. For these the bridge must ignore the existing javadoc and implement the behavior as described in the next section <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.1.3.1">6.1.3.1</a>.</p><a id="a-name6131"></a><h4><a name="6.1.3.1">6.1.3.1 Methods that deviate from Faces 1.2 Javadoc</h4><p>The following methods require an implementation that aren&rsquo;t adequately described in the Faces 1.2 <code>ExternalContext</code> javadoc:</p>
<ul>
  <li><code>dispatch()</code>:</li>
</ul><p>Dispatch a request to the specified resource to create output for this response. This must be accomplished by calling the <code>javax.portlet.PortletContext</code> method <code>getRequestDispatcher()</code>, and calling the <code>forward()</code><sup>[<a href="TCK-Tests.html#6.3">6.3</a>]</sup> method on the resulting object unless <code>dispatch()</code> has already been called (at least once) within this portlet request. If <code>dispatch()</code> has already been called within this portlet request, then <code>include()</code> may be called rather than <code>forward()</code>. This situation might occur in a bridge that doesn&rsquo;t wrap the response prior to dispatch with a wrapper that prevents committing the response which happens implicitly at the completion of the forward processing.</p><p><strong>Note:</strong> Because the Portlet 1.0 bridge was restricted to using <code>include()</code>, rendering may appear differently when the application runs in a 1.0 vs. a 2.0 bridge. Specifically, in a portlet 2.0 bridge any markup written prior to calling <code>dispatch</code> will not be returned to the client, while it will in a portlet 1.0 bridge environment. For (potential) backwards compatibility a bridge may provide an implementation specific mechanism to be configured to support portlet 1.0 bridge dispatch behavior (only use <code>include</code>) as long as this is not the default behavior.</p>
<ul>
  <li><p><code>encodeActionURL()</code>:</p></li>
  <li><p>Process the <code>inputURL</code> and construct and encode a corresponding valid portlet (generally action) URL. If called during the <code>RENDER_PHASE</code> or <code>RESOURCE_PHASE</code>, return this URL so it can be written into the markup response. If called during the <code>ACTION_PHASE</code>, directly encode this URL in the action response. The value and form of the URL returned when running in the <code>ACTION_PHASE</code> is undefined although it must not be <code>null</code>. If called during the <code>EVENT_PHASE</code>, directly encode this URL in the event response. The value and form of the URL returned when running in the <code>EVENT_PHASE</code> is undefined although it must not be <code>null</code>.</p></li>
  <li><p>To process such an <code>inputURL</code> correctly, this method must:</p>
  <ul>
    <li>If the <code>inputURL</code> starts with the # character<sup>[<a href="TCK-Tests.html#6.4">6.4</a>]</sup> or the <code>inputURL</code> is an absolute path external to this portlet application<sup>[<a href="TCK-Tests.html#6.5">6.5</a>]</sup> return the <code>inputURL</code> unchanged.</li>
    <li>If the <code>inputURL</code> contains the parameter <code>javax.portlet.faces.DirectLink</code> (with a value of &ldquo;true&rdquo;) return an absolute path derived from the <code>inputURL</code>. Don&rsquo;t remove the <code>DirectLink</code> parameter if it exists<sup>[<a href="TCK-Tests.html#6.6">6.6</a>]</sup>. If the <code>inputURL</code> contains the parameter <code>javax.portlet.faces.DirectLink</code> and its value is false then remove the <code>javax.portlet.faces.DirectLink</code> parameter and its value from the query string and continue processing (using the next step concerning determining the target of the <code>URL</code>)<sup>[<a href="TCK-Tests.html#6.7">6.7</a>]</sup>.</li>
    <li>Determine the target of the <code>URL</code>:
    <ul>
      <li>If the <code>inputURL</code> starts with the URI scheme <code>&quot;portlet:&quot;</code> the target is the portlet itself. Interpret this <code>inputURL</code> as follows:
      <ul>
        <li>The scheme &ldquo;<code>portlet:</code>&rdquo; indicates that the target of this action is the portlet itself. Though generally used to generate links to nonFaces views in this portlet it can also be used to generate action or render links to a Faces view (including the current view).</li>
        <li>The scheme is followed by either the keyword <code>action</code>, <code>render</code> or <code>resource</code>. <code>render</code> indicates a portlet <code>renderURL</code> should be encoded<sup>[<a href="TCK-Tests.html#6.8">6.8</a>]</sup>. <code>action</code> indicates a portlet <code>actionURL</code> should be encoded<sup>[<a href="TCK-Tests.html#6.9">6.9</a>]</sup>. <code>resource</code> indicates a portlet <code>resourceURL</code> should be encoded<sup>[<a href="TCK-Tests.html#6.102">6.102</a>]</sup>.</li>
        <li>Following this url type indicator is an optional query string. Parameter value pairs in the query string are the parameters that are to be encoded into the <code>portletURL</code>. <pre></pre> To generate a link to a Faces view, encode the view as the value of either the <code>_jsfBridgeViewId</code> or <code>_jsfBridgeViewPath</code> parameter (depending on whether you are encoding the viewId or the viewPath). Targets of such references are run in new empty scopes. An exception is made when the target is the current view and either of the above parameters is included in the query string with a value of <code>_jsfBridgeCurrentView</code>. In this case the url is encoded with the current render parameters and hence retains access to its state/scope. In all cases the bridge removes the above parameter(s) from the query string before generating the encoded url. <pre></pre> For a resource url, a Faces view is only encoded if one of the <code>_jsfBridgeViewId</code> or <code>_jsfBridgeViewPath</code> parameters is included in the query string, otherwise a nonFaces resource url is generated. The <code>_jsfBridgeCurrentView</code> value is used as a shortcut to indicate the resource targets the current view. <pre></pre> A simplified BNF is:<br> <code>portletURL = Scheme URLType [QueryString]</code><br> <code>Scheme = &quot;portlet:&quot;</code><br> <code>URLType = (&quot;action&quot; | &quot;render&quot; | &quot;resource&quot;)</code><br> <code>QueryString = &quot;?&quot; ParameterPair {&quot;&amp;&quot; ParameterPair}</code><br> <code>ParameterPair =  Text &quot;=&quot; Text</code><br> <pre></pre></li>
      </ul></li>
      <li>If the <code>inputURL</code> contains a full or relative path then analyze the  path information to determine whether it encodes a request to a Faces  view or a nonFaces view. If it is a reference to a Faces view the  target is the encoded Faces viewId<sup>[<a href="TCK-Tests.html#6.10">6.10</a>,  <a href="TCK-Tests.html#6.18">6.18</a>]</sup>. If it is a reference to a nonFaces  view, the target is the path that follows the context path (or if  relative, constructed relative to the current view path).
      <ul>
        <li>To determine if the <code>URL</code> represents a Faces request, determine  if the servlet container would map this URL to the Faces servlet.  This can be done by reading the servlet definitions in the web  application&rsquo;s <code>web.xml</code> to determine how the Faces servlet is  mapped and then checking the <code>URL</code> to see if it would be mapped. If  a Faces <code>URL</code>, derive the view identifier encoded in this <code>URL</code>, as  follows: (Note: all resulting <code>viewIds</code> start with a &ldquo;/&rdquo;)
        <ul>
          <li>If prefix mapping (such as “/faces/*”) is used for the  <code>FacesServlet</code>, the <code>viewId</code> is set from the extra path  information of the request <code>URI</code>. This corresponds to the path  that follows the prefix mapping. e.g. a prefix mapped URL such  as /faces/mypage.jsp would have a <code>viewId</code> of &ldquo;/mypage.jsp&rdquo;.</li>
          <li>If suffix mapping (such as “*.faces”) is used for  <code>FacesServlet</code>, the <code>viewId</code> is set from the servlet path  information of the request URI, after replacing the suffix with  the value of the context initialization parameter named by the  symbolic constant <code>ViewHandler.DEFAULT_SUFFIX_PARAM_NAME</code> (if  no such context initialization parameter is present, use the  value of the symbolic constant <code>ViewHandler.DEFAULT_SUFFIX</code> as  the replacement suffix). This corresponds to the path that  follows the context path. e.g. a suffix mapped URL such as  /pages/secondpage.jsf would have a <code>viewId</code> of  &ldquo;/pages/secondpage.jsp&rdquo; (assuming .jsp is the replacement  suffix).</li>
        </ul></li>
      </ul></li>
    </ul></li>
    <li>Process PortletURL related state modifications.
    <ul>
      <li>The portlet model allows one to encode changes to the portlet&rsquo;s mode, window state and or security (access) level in self-referencing URLs or as a response to an action request. Because the form of this encoding is not specified by the portlet standard these values aren&rsquo;t manipulated in the portlet URL&rsquo;s query string. Rather changes are expressed by operating directly on a <code>PortletURL</code> object (render phase) or the <code>actionResponse</code> (action phase). As <code>encodeActionURL()</code> isolates Faces clients from these APIs/objects, an alternative technique is provided so <code>encodeActionURL()</code> can recognize and incorporate the necessary changes. This technique recognizes special query string parameters in the <code>inputURL</code> which are extracted and processed using the corresponding APIs. encodeActionURL() processing must:
      <ul>
        <li>recognize the query string parameter <code>javax.portlet.faces.PortletMode</code> and use the value of this parameter to identify the mode that should be encoded in the generated reference<sup>[<a href="TCK-Tests.html#6.11">6.11</a>, <a href="TCK-Tests.html#6.19">6.19</a>]</sup>. If the value doesn&rsquo;t identify a valid mode then no encoding action is taken<sup>[<a href="TCK-Tests.html#6.12">6.12</a>, <a href="TCK-Tests.html#6.19">6.19</a>]</sup>. Regardless of validity, it must also prevent this query string parameter from being carried forward directly in the generated reference.</li>
        <li>recognize the query string parameter <code>javax.portlet.faces.WindowState</code> and use the value of this parameter to identify the window state that should be encoded in the generated reference<sup>[<a href="TCK-Tests.html#6.13">6.13</a>, <a href="TCK-Tests.html#6.21">6.21</a>]</sup>. If the value doesn&rsquo;t identify a valid window state then no encoding action is taken<sup>[<a href="TCK-Tests.html#6.14">6.14</a>, <a href="TCK-Tests.html#6.22">6.22</a>]</sup>. Regardless of validity, it must also prevent this query string parameter from being carried forward directly in the generated reference.</li>
        <li>recognize the query string parameter <code>javax.portlet.faces.Secure</code> and use the value of this parameter to identify the security level that should be encoded in the generated reference<sup>[<a href="TCK-Tests.html#6.15">6.15</a>, <a href="TCK-Tests.html#6.23">6.23</a>]</sup>. A value of true or false is translated into the boolean true/false respectively regardless of case. Any other value is ignored<sup>[<a href="TCK-Tests.html#6.16">6.16</a>, <a href="TCK-Tests.html#6.24">6.24</a>]</sup>. Regardless of validity, it must also prevent this query string parameter from being carried forward directly in the generated reference.</li>
        <li>All other query string parameters are added to the PortletURL as parameters<sup>[<a href="TCK-Tests.html#6.17">6.17</a>, <a href="TCK-Tests.html#6.25">6.25</a>]</sup>.</li>
      </ul></li>
    </ul></li>
    <li>Perform the encoding:
    <ul>
      <li>If executed during the <code>ACTION_PHASE</code> encode into the <code>ActionResponse</code> and return a non null <code>URL</code> as follows<sup>[<a href="TCK-Tests.html#6.10">6.10-6.17</a>]</sup>:
      <ul>
        <li>the target, if the target is not the portlet itself (as identified by use of the <code>portlet: URI</code>). When the target is a Faces <code>viewId</code>, it is encoded in an implementation dependent manner. When the target is a nonFaces view, the target is encoded as the value of the parameter named <code>_jsfBridgeNonFacesView</code>.</li>
        <li>the identified state modifications</li>
        <li>any additional query string parameters that were in the <code>inputURL</code>.</li>
      </ul></li>
      <li>If executed during the <code>EVENT_PHASE</code> encode into the <code>EventResponse</code>  and return a non null <code>URL</code> as follows<sup>[<a href="TCK-Tests.html#6.103">6.103-6.110</a>]</sup>:
      <ul>
        <li>the target (see action description)</li>
        <li>the identified state modifications</li>
        <li>any additional query string parameters that were in the  <code>inputURL</code>.</li>
      </ul></li>
      <li>If executed during the <code>RENDER_PHASE</code> or <code>RESOURCE_PHASE</code> and the  target was determined by url path (not portlet: syntax) and that target  is a Faces viewId, construct and return an <code>actionURL</code> by calling  <code>getResponse().createActionURL().toString()</code> as  follows<sup>[<a href="TCK-Tests.html#6.18">6.18-6.25</a>,  <a href="TCK-Tests.html#6.111">6.111-6.118</a>]</sup>:
      <ul>
        <li>encode the target determined above (in an implementation  dependent manner).</li>
        <li>the identified state modifications,</li>
        <li>any additional query string parameters that were in the  <code>inputURL</code>.</li>
      </ul></li>
      <li>If executed during the <code>RENDER_PHASE</code> or <code>RESOURCE_PHASE</code> and the  target was determined by its url path (not portlet: syntax) and that  target is a nonFaces <code>viewId</code>, construct and return a <code>renderURL</code> by  calling <code>getResponse().createRenderURL().toString()</code> as  follows<sup>[<a href="TCK-Tests.html#6.136">6.136-6.152</a>]</sup>:
      <ul>
        <li>encode the target determined above as the value of the parameter  named <code>_jsfBridgeNonFacesView</code>.</li>
        <li>the identified state modifications.</li>
        <li>any additional query string parameters that were in the  <code>inputURL</code>.</li>
      </ul></li>
      <li>If executed during the <code>RENDER_PHASE</code> or <code>RESOURCE_PHASE</code> and the  target was determined from the portlet: syntax (not by path), construct  the appropriate <code>URL</code> type determined from the path portion of the  based on the <code>urlTypeInputURL</code> and return its value in <code>String</code> form  (using <code>toString()</code>) as follows:
      <ul>
        <li>encode the identified state modifications.</li>
        <li>any additional query string parameters that were in the  <code>inputURL</code>.</li>
        <li>if the target of this url is the current JSF view as determined  by the use of the <code>_jsfBridgeCurrentView</code> value, additionally  encode all current render parameters into the portletURL. Return  <code>portletURL.toString()</code>. <pre></pre>  Note on encoding/xml escaping: because renderkits have their own  pre/post processing to deal with situations calling for xml escaping in  urls, the bridge must return an url that contains the identical xml  escaping (or not) used in the url passed to encodeActionURL. I.e. if  the incoming url is xml escaped the the returned url must also be xml  escaped, likewise if the incoming url isn&rsquo;t escaped the returned url  must not be escaped. In the case xml escaping can&rsquo;t be determined from  the incoming url, the bridge must assume the url is not xml escaped and  return an unescaped url  accordingly.<sup>[<a href="TCK-Tests.html#6.99">6.99</a>]</sup></li>
      </ul></li>
    </ul></li>
  </ul></li>
  <li><p><code>encodeResourceURL()</code>: <pre></pre> In Portlet 1.0 resources were not served by the portlet but rather accessed directly by the consumer using an http (resource) request. Portlet 2.0 introduces a second type of resourceURL, a (in-protocol) portlet served resource. A resourceURL of this type signifies that the portlet itself should be called by the consumer to generate the resource. The Portlet 2.0 APIs provide distinct calls for creating a reference to portlet served resource to one that is accessed directly. As Faces only has a single concept of a resourceURL, the bridge uses a heuristic to determine which of these two access methods it uses to reference the resource. In summary, resourceURLs that target a Faces view are constructed to be served by the portlet while those that don&rsquo;t target a Faces view are constructed to be accessed directly. <pre></pre> This method returns the inputURL after performing any rewriting needed to ensure that it will correctly identify an addressable resource. To process such an inputURL correctly, this method must:</p>
  <ul>
    <li>If the <code>inputURL</code> is <em>opaque</em>, in that it is an absolute URI with a scheme-specific part that doesn&rsquo;t begin with a slash character (e.g. <code>mailto:java-net@java.sun.com</code>) and the scheme isn&rsquo;t portlet:, return the <code>inputURL</code> unchanged<sup>[<a href="TCK-Tests.html#6.26">6.26</a>]</sup>.</li>
    <li>If the inputURL &rsquo;s scheme specific part is portlet: or its not opaque and its query string contains the parameter javax.portlet.faces.ViewLink with a value equal to true[6.34], then return an url representing a view navigation. This is done by:
    <ul>
      <li>if its exists, remove the <code>javax.portlet.faces.ViewLink</code> query string parameter. Note: This supports use cases such as using h:outputLink to navigate to a new view.</li>
      <li>if it exists, replace the <code>javax.portlet.faces.BackLink</code> query string parameter with a parameter whose name is the value of this parameter and whose value is the <code>String</code> (<code>URL</code> path) returned after calling <code>ViewHandler.getActionURL()</code> passing the current <code>viewId</code><sup>[<a href="TCK-Tests.html#6.27">6.27</a>]</sup>. <pre></pre> This encodes a &ldquo;back link&rdquo; into the resource URL allowing the targeted resource a way back to the calling portlet page for use in the situation where the <code>resourceURL</code> actually is used as a page link. E.g. use of <code>h:outputLink</code>.</li>
      <li>returning the result of calling <code>encodeActionURL</code> passing this transformed <code>inputURL</code><sup>[<a href="TCK-Tests.html#6.33">6.33</a>, <a href="TCK-Tests.html#6.34">6.34</a>]</sup>.</li>
    </ul></li>
    <li>If the <code>inputURL</code> is <em>hierarchical</em>, in that it is either an an absolute URI whose scheme-specific part begins with a slash character, or a relative URI, that is, a URI that does not specify a scheme, and it targets a resource that is external to this application:
    <ul>
      <li>check to see if the <code>inputURL</code> contains a query string parameter named <code>javax.portlet.faces.BackLink</code>. If it does replace it with a parameter whose name is the value of this parameter and whose value is the <code>String</code> (<code>URL</code> path) returned after calling <code>ViewHandler.getActionURL()</code> passing the current <code>viewId</code> followed by <code>ExternalContext.encodeActionURL()</code><sup>[<a href="TCK-Tests.html#6.27">6.27</a>]</sup>. <pre></pre> This encodes a &ldquo;back link&rdquo; into the resource <code>URL</code> allowing the targeted resource a way back to the calling portlet page for use in the situation where the <code>resourceURL</code> actually is used as a page link. E.g. use of <code>h:outputLink</code>. <pre></pre></li>
      <li>return <code>getResponse().encodeURL(inputURL)</code><sup>[<a href="TCK-Tests.html#6.28">6.28</a>]</sup>.</li>
    </ul></li>
    <li>If the <code>inputURL</code> is <em>hierarchical</em> and targets a resource that is within this application:
    <ul>
      <li>if the <code>inputURL</code> is a relative <code>URL</code> (i.e. it is neither absolute nor starts with a &lsquo;/&rsquo;) then the <code>inputURL</code> must be turned into a context path relative URL by constructing a new url based on going relative to the current path<sup>[<a href="TCK-Tests.html#6.29">6.29</a>]</sup>. The current path is defined as the path that would be used to <code>dispatch()</code> to the current view.</li>
      <li>ensure that the <code>inputURL</code> (potentially modified by the previous step) is a fully qualified path <code>URI</code> (i.e. contains the context path)<sup>[<a href="TCK-Tests.html#6.31">6.31</a>]</sup>.</li>
      <li>if the resulting <code>inputURL</code> contains a query string parameter named <code>javax.portlet.faces.BackLink</code> then replace it with a parameter whose name is the value of this parameter and whose value is the <code>String</code> (<code>URL</code> path) returned after calling <code>ViewHandler.getActionURL()</code> passing the current <code>viewId</code><sup>[<a href="TCK-Tests.html#6.30">6.30</a>]</sup>. <pre></pre> This encodes a &ldquo;back link&rdquo; into the resource URL allowing the targeted resource a way back to the calling portlet page. E.g. use of <code>h:outputLink</code>.</li>
      <li>determine whether the targeted resources will be satisfied using Portlet 2.0 in protocol resource serving support or Portlet 1.0 out of band http support. The bridge must encode the resource to be satisfied by the in protocol resource serving support if:
      <ul>
        <li>the query string contains the parameter <code>javax.portlet.faces.InProtocolResourceLink</code></li>
        <li>the target is a Faces resource, one that in a servlet environment would be processed running through the <code>FacesServlet</code>. <pre></pre> Note: The bridge can choose the strategy for acquiring (representing) all other resources though it is noted that out of band (http) resource access is generally more efficient.</li>
      </ul></li>
      <li>if returning an in protocol resource, return the <code>String</code> representation of a <code>resourceURL</code> created using <code>response.createResourceURL()</code> after processing <code>PortletURL</code> related state modifications:
      <ul>
        <li>as you can&rsquo;t change a portlet&rsquo;s mode in a resource request, remove and ignore the query string parameter <code>javax.portlet.faces.PortletMode</code> if it exists.</li>
        <li>as you can&rsquo;t change a portlet&rsquo;s window state in a resource request, remove and ignore the query string parameter <code>javax.portlet.faces.WindowState</code> if it exists.</li>
        <li>recognize the query string parameter <code>javax.portlet.faces.Secure</code> and use the value of this parameter to identify the security level that should be encoded in the generated reference. A value of <code>true</code> or <code>false</code> is translated into the <code>boolean true/false</code> respectively regardless of case. Any other value is ignored. Regardless of validity, it must also prevent this query string parameter from being carried forward directly in the generated reference.</li>
        <li>All other query string parameters are added to the <code>ResourceURL</code> as parameters.</li>
        <li>if returning an out of band (http) resource return <code>getResponse().encodeURL(inputURL)</code><sup>[<a href="TCK-Tests.html#6.28">6.28</a>]</sup>. <pre></pre> Note on encoding/xml escaping: because renderkits have their own pre/post processing to deal with situations calling for xml escaping in urls, the bridge must return an url that contains the identical xml escaping (or not) used in the url passed to <code>encodeActionURL</code>. I.e. if the incoming url is xml escaped the the returned url must also be xml escaped, likewise if the incoming url isn&rsquo;t escaped the returned url must not be escaped. In the case xml escaping can&rsquo;t be determined from the incoming url, the bridge must assume the url is not xml escaped and return an unescaped url accordingly<sup>[<a href="TCK-Tests.html#6.99">6.99</a>]</sup>. Also, because there are situations where Faces components will further encode returned URL strings by replacing <spaces> in the <code>URL</code> with the &lsquo;+&rsquo; which not all portlet containers may be able to subsequently process, the bridge can (should) <code>URL</code>-encode the space character (%20) prior to returning the <code>URL</code> regardless of any stipulation regarding base encoding.</li>
      </ul></li>
    </ul></li>
  </ul></li>
  <li><p><code>getRequest()</code>:</p><p>Return the environment-specific object instance for the current request. This must be the last request object set as a consequence of calling <code>setRequest()</code><sup>[<a href="TCK-Tests.html#6.35">6.35</a>]</sup> or if none set, the request object passed to this instance&rsquo;s constructor.</p></li>
  <li><p><code>setRequest()</code>:</p><p>Set the environment-specific request to be returned by subsequent calls to <code>getRequest()</code><sup>[<a href="TCK-Tests.html#6.35">6.35</a>]</sup>. This may be used to install a wrapper for the request.</p></li>
  <li><p><code>setRequestCharacterEncoding()</code>:</p><p>Overrides the name of the character encoding used in the body of this request<sup>[<a href="TCK-Tests.html#6.37">6.37</a>]</sup>.</p><p>Calling this method after reading request parameters or reading input has no effect and throws no exceptions. Calling this method during the RENDER_PHASE is has no effect and throws no exceptions<sup>[<a href="TCK-Tests.html#6.36">6.36</a>]</sup>.</p></li>
  <li><p><code>getRequestHeaderMap()</code>:</p><p>Return an immutable <code>Map</code> whose keys are the set of request header names included in the current request, and whose values (of type <code>String</code>) are the first (or only) value for each header name returned by the underlying request<sup>[<a href="TCK-Tests.html#6.35">6.38</a>, <a href="TCK-Tests.html#6.39">6.39</a>, <a href="TCK-Tests.html#6.119">6.119</a>, <a href="TCK-Tests.html#6.120">6.120</a>]</sup>. The returned <code>Map</code> must implement the entire contract for an unmodifiable <code>Map</code> as described in the JavaDocs for <code>java.util.Map</code><sup>[<a href="TCK-Tests.html#6.38">6.38</a>, <a href="TCK-Tests.html#6.39">6.39</a>, <a href="TCK-Tests.html#6.119">6.119</a>, <a href="TCK-Tests.html#6.120">6.120</a>]</sup>. In addition, key comparisons must be performed in a case insensitive manner.</p><p>This Map must include the set of properties available via the <code>javax.portlet.PortletRequest</code> methods <code>getProperty()</code> and <code>getPropertyNames()</code> except when executing a <code>RENDER_REQUEST</code> or an <code>EVENT_REQUEST</code>. Within a <code>RENDER_REQUEST</code> or <code>EVENT_REQUEST</code>, the map must exclude the <code>CONTENT-TYPE</code> and <code>CONTENT-LENGTH properties</code> (if they are present in the underlying request)<sup>[<a href="TCK-Tests.html#6.38">6.38</a>, <a href="TCK-Tests.html#6.119">6.119</a>]</sup>.</p><p>In addition, to provide compatibility with servlets, the bridge must ensure that the following entries exist in the <code>Map</code> when the bridge is executing during an <code>ACTION_PHASE</code> or <code>RESOURCE_PHASE</code>: <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Type</code>, and <code>Content-Length</code><sup>[<a href="TCK-Tests.html#6.39">6.39</a>, <a href="TCK-Tests.html#6.120">6.120</a>]</sup>. When executing during a <code>RENDER_PHASE</code> or an <code>EVENT_PHASE</code> the bridge must only ensure that <code>Accept</code> and <code>Accept-Language</code> exist (and as noted above that <code>Content-Type</code> and <code>Content-Length</code> don&rsquo;t exist)<sup>[<a href="TCK-Tests.html#6.38">6.38</a>, <a href="TCK-Tests.html#6.119">6.119</a>]</sup>. The values for these headers are derived as follows:</p>
  <ul>
    <li><code>Accept</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getResponseContentTypes()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Accept header format</a> as defined by RFC2616 Section 14.1.</li>
  </ul>
  <ul>
    <li><code>Accept-Language</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getLocales()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Accept-Language header format</a> as defined by RFC2616 Section 14.4.</li>
  </ul>
  <ul>
    <li><code>Content-Type</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getContentType()</code> and <code>getCharacterEncoding()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Content-Type header format</a> as defined by RFC2616 Section 14.17. This header value must only be represented if <code>getContentType()</code> returns a non-null value. The character set portion of this header must only be represented if <code>getCharacterEncoding()</code> returns a non-null value.</li>
  </ul>
  <ul>
    <li><code>Content-Length</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getContentLength()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Content-Length header format</a> as defined by RFC2616 Section 14.13. This header value must only be represented if <code>getContentLength()</code> returns a value other then -1.</li>
  </ul></li>
  <li><p><code>getRequestHeaderValuesMap()</code>: </p><p>Return an immutable <code>Map</code> whose keys are the set of request header names included in the current request, and whose values (of type <code>String[]</code>) are all of the value for each header name returned by the underlying request<sup>[<a href="TCK-Tests.html#6.40">6.40</a>, <a href="TCK-Tests.html#6.41">6.41</a>, <a href="TCK-Tests.html#6.121">6.121</a>, <a href="TCK-Tests.html#6.122">6.122</a>]</sup>. The returned <code>Map</code> must implement the entire contract for an unmodifiable <code>Map</code> as described in the JavaDocs for <code>java.util.Map</code><sup>[<a href="TCK-Tests.html#6.40">6.40</a>, <a href="TCK-Tests.html#6.41">6.41</a>, <a href="TCK-Tests.html#6.121">6.121</a>, <a href="TCK-Tests.html#6.122">6.122</a>]</sup>. In addition, key comparisons must be performed in a case insensitive manner.</p><p>This <code>Map</code> must include the set of property names and values available via the <code>javax.portlet.PortletRequest</code> methods <code>getProperty()</code> and <code>getPropertyNames()</code> except when executing a <code>RENDER_REQUEST</code> or an <code>EVENT_REQUEST</code>. Within a <code>RENDER_REQUEST</code> or <code>EVENT_REQUEST</code>, the map must exclude the <code>CONTENT-TYPE</code> property (if it is present in the underlying request)<sup>[<a href="TCK-Tests.html#6.40">6.40</a>, <a href="TCK-Tests.html#6.121">6.121</a>]</sup>.</p><p>In addition, to provide compatibility with servlets, the bridge must ensure that the following entries exist in the Map when the bridge is executing during an <code>ACTION_PHASE</code> or <code>RESOURCE_PHASE</code>: <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Type</code>, and <code>Content-Length</code><sup>[<a href="TCK-Tests.html#6.41">6.41</a>, <a href="TCK-Tests.html#6.122">6.122</a>]</sup>. When executing during a <code>RENDER_PHASE</code> or an <code>EVENT_PHASE</code> the bridge must only ensure that <code>Accept</code> and <code>Accept-Language</code> exist (and as noted above that <code>Content-Type</code> doesn&rsquo;t exist)<sup>[<a href="TCK-Tests.html#6.40">6.40</a>, <a href="TCK-Tests.html#6.121">6.121</a>]</sup>. The values for these headers are derived as follows:</p>
  <ul>
    <li><code>Accept</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getResponseContentTypes()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Accept header format</a> as defined by RFC2616 Section 14.1.</li>
  </ul>
  <ul>
    <li><code>Accept-Language</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getLocales()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Accept-Language header format</a> as defined by RFC2616 Section 14.4.</li>
  </ul>
  <ul>
    <li><code>Content-Type</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getContentType()</code> and <code>getCharacterEncoding()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Content-Type header format</a> as defined by RFC2616 Section 14.17. This header value must only be represented if <code>getContentType()</code> returns a non-null value. The character set portion of this header must only be represented if <code>getCharacterEncoding()</code> returns a non-null value.</li>
  </ul>
  <ul>
    <li><code>Content-Length</code>: The value returned for this header must be the result of properly encoding the values returned by <code>getContentLength()</code> as a string conforming to the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">HTTP 1.1 Content-Length header format</a> as defined by RFC2616 Section 14.13. This header value must only be represented if <code>getContentLength()</code> returns a value other then -1.</li>
  </ul></li>
  <li><p><code>getRequestMap()</code>:</p><p>Return a mutable <code>Map</code> representing the request scope attributes for the current application<sup>[<a href="TCK-Tests.html#6.42">6.42</a>]</sup>. The returned <code>Map</code> must implement the entire contract for a modifiable map as described in the JavaDocs for <code>java.util.Map</code>. Modifications made in the <code>Map</code> must cause the corresponding changes in the set of request scope attributes. Particularly the <code>clear()</code>, <code>remove()</code>, <code>put()</code>, <code>putAll()</code>, and <code>get()</code> operations must take the appropriate action on the underlying data structure<sup>[<a href="TCK-Tests.html#6.42">6.42</a>]</sup>.</p><p>For any of the Map methods that cause an element to be removed from the underlying data structure, the following occurs <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces#6.8">6.8</a>:</p>
  <ul>
    <li>If the attribute is excluded from the bridge request scope and the attribute&rsquo;s value is a managed-bean, and it has one or more public no-argument void return methods annotated with <code>javax.annotation.PreDestroy</code>, then each such method must be called before the element is removed from the underlying data structure. Elements that are not managed-beans, but do happen to have methods with that annotation must not have those methods called on removal.</li>
  </ul>
  <ul>
    <li>If the attribute is included in the bridge request scope then regardless of whether the attribute is a managed-bean or not, if the attribute&rsquo;s value has one or more public no-argument void return methods annotated with <code>javax.portlet.faces.annotation.PreDestroy</code>, then each such method must be called before the element is removed from the underlying data structure<sup>[<a href="TCK-Tests.html#6.42">6.42</a>/<a href="TCK-Tests.html#nt">nt</a>]</sup>.</li>
  </ul><p>Any exception thrown by either of these <code>PreDestroy</code> annotated methods must by caught and not rethrown. The exception may be logged.</p><p>The <code>Map</code> must contain the set of attributes available via the <code>javax.portlet.PortletRequest</code> methods <code>getAttribute()</code>, <code>getAttributeNames()</code>, <code>removeAttribute()</code>, and <code>setAttribute()</code>. Furthermore these attributes must be managed across portlet requests according to the rules defined in section <a href="Chapter-5-Bridge-Lifecycle-Requirements.html#5.1.2">5.1.2</a><sup>[<a href="TCK-Tests.html#6.43">6.43</a>]</sup>.</p></li>
  <li><p><code>getRequestParameterMap()</code>: </p><p>Return an immutable <code>Map</code> whose keys are the set of request parameters names included in the current request, and whose values (of type <code>String</code>) are the first (or only) value for each parameter name returned by the underlying request<sup>[<a href="TCK-Tests.html#6.45">6.45</a>]</sup>. The returned <code>Map</code> must implement the entire contract for an unmodifiable map as described in the JavaDocs for <code>java.util.Map</code>.</p><p>This <code>Map</code> must be composed from the set of parameters available via the <code>javax.portlet.PortletRequest</code> methods <code>getParameter()</code> and <code>getParameterNames()</code> plus any additional parameter names encoded in the (query string) of the <code>viewId</code><sup>[<a href="TCK-Tests.html#6.47">6.47</a>]</sup>. This later situation primarily occurs when using a default <code>viewId</code> provided by the portlet.</p><p>In addition, during a portlet&rsquo;s <code>RENDER_PHASE</code>, if not otherwise already in the <code>Map</code>, the bridge must include those parameters managed in the corresponding bridge request scope. This always includes the <code>ResponseStateManger.VIEW_STATE_PARAM
parameter</code><sup>[<a href="TCK-Tests.html#6.45">6.45</a>]</sup>. The preservation/inclusion of the rest of the action parameters depends on the <code>javax.portlet.faces.[portlet name].preserveActionParams</code> portlet context attribute. If this context attribute exists and has a value of <code>Boolean.TRUE</code>, the additional action parameters are preserved/included<sup>[<a href="TCK-Tests.html#6.46">6.46</a>]</sup>, otherwise they aren&rsquo;t.</p></li>
  <li><p><code>getRequestParameterNames()</code>:</p><p>Return an <code>Iterator</code> over the names of all request parameters included in the current request. This must be an <code>Iterator</code> over the values returned by the <code>javax.portlet.PortletRequest</code> method <code>getParameterNames()</code><sup>[<a href="TCK-Tests.html#6.48">6.48</a>]</sup> plus any additional parameter names encoded in the (query string) of the <code>viewId</code><sup>[<a href="TCK-Tests.html#6.50">6.50</a>]</sup>. This later situation primarily occurs when using a default <code>viewId</code> provided by the portlet.</p><p>In addition, during a portlet&rsquo;s <code>RENDER_PHASE</code>, if not otherwise already in the <code>Iterator</code>, the bridge must include those parameter names managed in the corresponding bridge request scope. This always includes the <code>ResponseStateManger.VIEW_STATE_PARAM</code> parameter<sup>[<a href="TCK-Tests.html#6.48">6.48</a>]</sup>. The preservation/inclusion of the rest of the action parameters depends on the <code>javax.portlet.faces.[portlet name].preserveActionParams</code> portlet context attribute. If this context attribute exists and has a value of <code>Boolean.TRUE</code>, the additional action parameters are preserved/included<sup>[<a href="TCK-Tests.html#6.49">6.49</a>]</sup>, otherwise they aren&rsquo;t.</p></li>
  <li><p><code>getRequestParameterValuesMap()</code>:</p><p>Return an immutable <code>Map</code> whose keys are the set of request parameters names included in the current request, and whose values (of type <code>String[]</code>) are all of the values for each parameter name returned by the underlying request<sup>[<a href="TCK-Tests.html#6.51">6.51</a>]</sup>. The returned <code>Map</code> must implement the entire contract for an unmodifiable map as described in the JavaDocs for <code>java.util.Map</code>.</p><p>This must be the set of parameter values available via the <code>javax.portlet.PortletRequest</code> methods <code>getParameterValues()</code> and <code>getParameterNames()</code> plus any additional parameter names encoded in the (query string) of the <code>viewId</code><sup>[<a href="TCK-Tests.html#6.53">6.53</a>]</sup>. This later situation primarily occurs when using a default <code>viewId</code> provided by the portlet.</p><p>In addition, during a portlet&rsquo;s <code>RENDER_PHASE</code>, if not otherwise already in the <code>Map</code>, the bridge must include those parameter names managed in the corresponding bridge request scope. This always includes the <code>ResponseStateManger.VIEW_STATE_PARAM</code> parameter<sup>[<a href="TCK-Tests.html#6.51">6.51</a>]</sup>. The preservation/inclusion of the rest of the action parameters depends on the <code>javax.portlet.faces.[portlet name].preserveActionParams</code> portlet context attribute<sup>[<a href="TCK-Tests.html#6.52">6.52</a>]</sup>. If this context attribute exists and has a value of <code>Boolean.TRUE</code>, the additional action parameters are preserved/included, otherwise they aren&rsquo;t.</p></li>
  <li><p><code>getRequestPathInfo()</code>:</p><p>Return the extra path information (if any) included in the request <code>URI</code>; otherwise, return <code>null</code>. This value must represent the path portion of the current target <code>viewId</code>.</p><p>Because the portlet model doesn&rsquo;t support a (servlet) equivalent notion of <code>pathInfo</code> and <code>servletPath</code>, the bridge must manufacture these values based on the target <code>viewId</code>. The bridge determines the target view from request parameter(s) it has previously encoded. If this information doesn&rsquo;t exist, the target view is the default <code>viewId</code> defined by the portlet. The associated pathInfo and servletPath are constructed by determining the servlet mapping of the Faces servlet and constructing the appropriate paths such that they conform to the paths the servlet container generates when processing an http request which targets this view as defined in SRV .4.4 in the Servlet 2.5 specification<sup>[<a href="TCK-Tests.html#6.54">6.54</a>]</sup>.</p><p>Examples:</p>
  <table border="1">
    <tr>
        <th>Faces servlet mapping</th>
        <th>viewId</th>
        <th>servletPath</th>
        <th>pathInfo</th>
    </tr>
    <tr>
        <td>/faces/* (prefix mapping)</td>
        <td>myView.jspx</td>
        <td>/faces</td>
        <td>myView.jspx</td>
    </tr>
    <tr>
        <td>*.jsf (suffix mapping)</td>
        <td>myView.jspx</td>
        <td>myView.jsf</td>
        <td>null</td>
    </tr>
</table></li>
</ul>
<!--| Faces servlet mapping     | viewId      | servletPath | pathInfo    |
    |---------------------------|-------------|-------------|-------------|
    | /faces/* (prefix mapping) | myView.jspx | /faces      | myView.jspx |
    | *.jsf (suffix mapping)    | myView.jspx | myView.jsf  | null        |-->
<ul>
  <li><p><code>getRequestServletPath()</code>:</p><p>Returns the part of this request&rsquo;s URL that calls the servlet. This path starts with a &ldquo;/&rdquo; character and includes either the servlet name or a path to the servlet, but does not include any extra path information or a query string.</p><p>This method will return an empty string (&quot;&ldquo;) if the servlet used to process this request was matched using the &rdquo;/*&quot; pattern.</p><p>Because the portlet model doesn&rsquo;t support a (servlet) equivalent notion of <code>pathInfo</code> and <code>servletPath</code>, the bridge must manufacture these values based on the target <code>viewId</code>. The bridge determines the target view from request parameter(s) it has previously encoded. If this information doesn&rsquo;t exist, the target view is the default <code>viewId</code> defined by the portlet. The associated pathInfo and servletPath are constructed by determining the servlet mapping of the Faces servlet and constructing the appropriate paths such that they conform to the paths the servlet container generates when processing an http request which targets this view as defined in SRV .4.4 in the Servlet 2.5 specification<sup>[<a href="TCK-Tests.html#6.55">6.55</a>]</sup>.</p>
  <pre><code>Examples:
</code></pre>
  <table border="1">
    <tr>
        <th>Faces servlet mapping</th>
        <th>viewId</th>
        <th>servletPath</th>
        <th>pathInfo</th>
    </tr>
    <tr>
        <td>/faces/* (prefix mapping)</td>
        <td>myView.jspx</td>
        <td>/faces</td>
        <td>myView.jspx</td>
    </tr>
    <tr>
        <td>*.jsf (suffix mapping)</td>
        <td>myView.jspx</td>
        <td>myView.jsf</td>
        <td>null</td>
    </tr>
</table></li>
</ul>
<!--| Faces servlet mapping     | viewId      | servletPath | pathInfo    |
    |---------------------------|-------------|-------------|-------------|
    | /faces/* (prefix mapping) | myView.jspx | /faces      | myView.jspx |
    | *.jsf (suffix mapping)    | myView.jspx | myView.jsf  | null        |-->
<ul>
  <li><p><code>getRequestCharacterEncoding()</code>:</p><p>Return the character encoding currently being used to interpret this request. If called during the <code>ACTION_PHASE</code> or <code>RESOURCE_PHASE</code>, returns the value from the corresponding action <code>request.getCharacterEncoding()</code><sup>[<a href="TCK-Tests.html#6.57">6.57</a>, <a href="TCK-Tests.html#6.123">6.123</a>]</sup>. If called during the <code>RENDER_PHASE</code> or <code>EVENT_PHASE</code> it returns <code>null</code><sup>[<a href="TCK-Tests.html#6.56">6.56</a>, <a href="TCK-Tests.html#6.124">6.124</a>]</sup>.</p></li>
  <li><p><code>getRequestContentType()</code>: </p><p>Return the MIME Content-Type for this request. If called during the <code>ACTION_PHASE</code> or <code>RESOURCE_PHASE</code>, returns the value from the corresponding action <code>request.getContentType()</code><sup>[<a href="TCK-Tests.html#6.59">6.59</a>, <a href="TCK-Tests.html#6.125">6.125</a>]</sup>. If called during he <code>RENDER_PHASE</code> or <code>EVENT_PHASE</code> it returns <code>null</code><sup>[<a href="TCK-Tests.html#6.58">6.58</a>, <a href="TCK-Tests.html#6.126">6.126</a>]</sup>.</p></li>
  <li><p><code>getResponseCharacterEncoding()</code>: </p><p>Returns the name of the character encoding (MIME charset) used for the body sent in this response. If called during the <code>RENDER_PHASE</code> or <code>RESOURCE_PHASE</code>, returns the value from the corresponding render <code>response.getCharacterEncoding()</code><sup>[<a href="TCK-Tests.html#6.60">6.60</a>, <a href="TCK-Tests.html#6.127">6.127</a>]</sup>. If called during the <code>ACTION_PHASE</code> or <code>EVENT_PHASE</code> it throws an <code>IllegalStateException</code><sup>[<a href="TCK-Tests.html#6.61">6.61</a>, <a href="TCK-Tests.html#6.128">6.128</a>]</sup>.</p></li>
  <li><p><code>getResponseContentType()</code>: </p><p>Return the MIME Content-Type for this response. If called during the <code>RENDER_PHASE</code> or <code>RESOURCE_PHASE</code>, returns the value from the corresponding render <code>response.getContentType()</code><sup>[<a href="TCK-Tests.html#6.62">6.62</a>, <a href="TCK-Tests.html#6.129">6.129</a>]</sup>. If called during the <code>ACTION_PHASE</code> or <code>EVENT_PHASE</code> it throws an <code>IllegalStateException</code><sup>[<a href="TCK-Tests.html#6.63">6.63</a>, <a href="TCK-Tests.html#6.130">6.130</a>]</sup>.</p></li>
  <li><p><code>getResponse()</code>:</p><p>Return the environment-specific object instance for the current response. This must be the last response object set as a consequence of calling <code>setResponse()</code> or if none set, the <code>response</code> object passed to this instance&rsquo;s constructor.</p></li>
  <li><p><code>setResponse()</code>:</p><p>Set the environment-specific response to be returned by subsequent calls to <code>getResponse()</code>. This may be used to install a wrapper for the response.</p></li>
  <li><p><code>redirect()</code>: <pre></pre> Redirect a request to the specified <code>URL</code>. <pre></pre> Because the portlet redirect semantics differ from servlets the bridge implements the following support: <pre></pre></p>
  <ul>
    <li>During an Action Request<sup>[<a href="TCK-Tests.html#6.64">6.64</a>]</sup>: <pre></pre>
    <ul>
      <li>if the redirect target url starts with &lsquo;#&rsquo;, references a resource outside of this web application, or contains the query string parameter <code>javax.portlet.faces.DirectLink</code> with a value of &ldquo;<code>true</code>&rdquo;, call <code>ActionResponse.sendRedirect()</code> passing the <code>url</code>. <pre></pre> This causes the client to redirect from the consumer page to this target. <pre></pre></li>
      <li>otherwise, ensure that the action response is set to cause the subsequent render to target this redirect view. Typically this merely involves ensuring that <code>encodeActionURL()</code> has been called on the target. <pre></pre> This is equivalent to a regular faces navigation, the client doesn&rsquo;t redirect, rather the consumer page renders the portlet&rsquo;s new target. <pre></pre> Note: in either case, <code>FacesContext.responseComplete()</code> must be called before returning. <pre></pre></li>
    </ul></li>
    <li>During an Event Request<sup>[<a href="TCK-Tests.html#6.131">6.131</a>]</sup>: <pre></pre>
    <ul>
      <li>if the redirect target url starts with &lsquo;#&rsquo;, references a resource outside of this web application, or contains the query string parameter <code>javax.portlet.faces.DirectLink</code> with a value of &ldquo;<code>true</code>&rdquo;. <pre></pre>  The redirect is ignored. <pre></pre></li>
      <li>otherwise, ensure that the event response is set to cause the subsequent render to target this redirect view. Typically this merely involves ensuring that <code>encodeActionURL()</code> has been called on the target. <pre></pre> This is equivalent to a regular faces navigation, the client doesn&rsquo;t redirect, rather the consumer page renders the portlet&rsquo;s new target. <pre></pre> Note: in either case, <code>FacesContext.responseComplete()</code> must be called before returning. <pre></pre></li>
    </ul></li>
    <li>During a Render Request: <pre></pre>
    <ul>
      <li>if the redirect target url starts with &lsquo;#&rsquo;, references a resource outside of this web application, or contains the query string parameter <code>javax.portlet.faces.DirectLink</code> with a value of &ldquo;<code>true</code>&rdquo;. <pre></pre> The redirect is ignored. <pre></pre></li>
      <li>if the redirect target url references a nonFaces view then throw an <code>IllegalStateException</code><sup>[<a href="TCK-Tests.html#6.66">6.66</a>]</sup>. <pre></pre></li>
      <li>otherwise, encode the redirect target and call <code>FacesContext.responseComplete()</code> to ensure the bridge will cease rendering its current view prior to returning any response content. Instead, render the redirect target and returns its output as the response<sup>[<a href="TCK-Tests.html#6.65">6.65</a>]</sup>. In addition, support this behavior so that subsequent rerenders will ignore the (original) request target and instead render with the (cached) redirect target URL and its preserved saved (render) view state. Special care is needed in managing public render parameters during a render redirect. The bridge must ensure that the public render parameters passed to this request are carried forward and processed during the rendering of the redirect that occurs within the same render request. However, if subsequent rerender (requests), the bridge must not use any of the public render parameters used in the initial render (redirect) but rather use the public render parameters that are reflected in the (new) request. <pre></pre></li>
    </ul></li>
    <li>During a Resource Request<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>: <pre></pre> The redirect is ignored. Take no action.</li>
  </ul></li>
</ul><a id="a-name6132"></a><h4><a name="6.1.3.2">6.1.3.2 Methods that conform with Faces 1.2 Javadoc</h4><p>The following methods require an implementation that are adequately described in the Faces 1.2 ExternalContext javadoc. This includes the implicit requirement that each access to the portlet <code>request</code> or <code>response</code> object be done by using the last <code>request</code> or <code>response</code> object set using the corresponding <code>setRequest()</code> or <code>setResponse()</code> methods or the original objects passed to the constructor if none have been directly set.</p>
<ul>
  <li><p><code>encodeNamespace()</code>:</p><p>Return the specified name, after prefixing it with a namespace that ensures that it will be unique within the context of a particular page. The returned value must be the input value prefixed by the value returned by the <code>javax.portlet.RenderResponse</code> method <code>getNamespace()</code><sup>[<a href="TCK-Tests.html#6.67">6.67</a>]</sup>.</p></li>
  <li><p><code>getApplicationMap()</code>:</p><p>Return a mutable <code>Map</code> representing the application scope attributes for the current application<sup>[<a href="TCK-Tests.html#6.68">6.68</a>]</sup>. This must be the set of attributes available via the <code>javax.portlet.PortletContext</code> methods <code>getAttribute()</code>, <code>getAttributeNames()</code>, <code>removeAttribute()</code>, and <code>setAttribute()</code>. The returned <code>Map</code> must implement the entire contract for a modifiable map as described in the JavaDocs for <code>java.util.Map</code>. Modifications made in the <code>Map</code> must cause the corresponding changes in the set of application scope attributes. Particularly the <code>clear()</code>, <code>remove()</code>, <code>put()</code>, <code>putAll()</code>, and <code>get()</code> operations must take the appropriate action on the underlying data structure.</p><p>For any of the <code>Map</code> methods that cause an element to be removed from the underlying data structure, the following action regarding managed-beans must be taken. If the element to be removed is a managed-bean, and it has one or more public no-argument void return methods annotated with <code>javax.annotation.PreDestroy</code>, each such method must be called before the element is removed from the underlying data structure. Elements that are not managed-beans, but do happen to have methods with that annotation must not have those methods called on removal. Any exception thrown by the <code>PreDestroy</code> annotated methods must by caught and not rethrown. The exception may be logged.</p></li>
  <li><p><code>getAuthType()</code>:</p><p>Return the name of the authentication scheme used to authenticate the current user, if any; otherwise, return <code>null</code><sup>[<a href="TCK-Tests.html#6.69">6.69</a>]</sup>. For standard authentication schemes, the returned value will match one of the following constants: <code>BASIC_AUTH</code>, <code>CLIENT_CERT_AUTH</code>, <code>DIGEST_AUTH</code>, or <code>FORM_AUTH</code>. This must be the value returned by the <code>javax.portlet.http.PortletRequest</code> method <code>getAuthType()</code>.</p></li>
  <li><p><code>getContext()</code>:</p><p>Return the application environment object instance for the current application. This must be the current application&rsquo;s <code>javax.portlet.PortletContext</code> instance<sup>[<a href="TCK-Tests.html#6.70">6.70</a>]</sup>.</p></li>
  <li><p><code>getInitParameter()</code>:</p><p>Return the value of the specified application initialization parameter (if any). This must be the result of the <code>javax.portlet.PortletContext</code> method <code>getInitParameter(name)</code><sup>[<a href="TCK-Tests.html#6.71">6.71</a>]</sup>.</p></li>
  <li><p><code>getInitParameterMap()</code>:</p><p>Return an immutable <code>Map</code> whose keys are the set of application initialization parameter names configured for this application, and whose values are the corresponding parameter values<sup>[<a href="TCK-Tests.html#6.72">6.72</a>]</sup>. The returned <code>Map</code> must implement the entire contract for an unmodifiable map as described in the JavaDocs for <code>java.util.Map</code>. This result must be as if it were synthesized by calling the <code>javax.portlet.PortletContext</code> method <code>getInitParameterNames</code>, and putting each configured parameter name/value pair into the result.</p></li>
  <li><p><code>getRemoteUser()</code>:</p><p>Return the login name of the user making the current request if any; otherwise, return <code>null</code>. This must be the value returned by the <code>javax.portlet.http.PortletRequest</code> method <code>getRemoteUser()</code><sup>[<a href="TCK-Tests.html#6.73">6.73</a>]</sup>.</p></li>
  <li><p><code>getRequestContextPath()</code>:</p><p>Return the portion of the request URI that identifies the web application context for this request. This must be the value returned by the <code>javax.portlet.PortletRequest</code> method <code>getContextPath()</code><sup>[<a href="TCK-Tests.html#6.74">6.74</a>]</sup>.</p></li>
  <li><p><code>getRequestCookieMap()</code>:</p><p>Return an immutable <code>Map</code> whose keys are the set of cookie names included in the current request, and whose values (of type <code>javax.servlet.http.Cookie</code>) are the first (or only) cookie for each cookie name returned by the underlying request. The returned <code>Map</code> must implement the entire contract for an unmodifiable map as described in the JavaDocs for <code>java.util.Map</code>.</p><p>This must be an empty Map<sup>[<a href="TCK-Tests.html#6.75">6.75</a>]</sup>.</p></li>
  <li><p><code>getRequestLocale()</code>:</p><p>Return the preferred <code>Locale</code> in which the client will accept content. This must be the value returned by the <code>javax.portlet.PortletRequest</code> method <code>getLocale()</code><sup>[<a href="TCK-Tests.html#6.76">6.76</a>]</sup>.</p></li>
  <li><p><code>getRequestLocales()</code>:</p><p>Return an <code>Iterator</code> over the preferred <code>Locale</code>s specified in the request, in decreasing order of preference. This must be an <code>Iterator</code> over the values returned by the <code>javax.portlet.PortletRequest</code> method <code>getLocales()</code><sup>[<a href="TCK-Tests.html#6.77">6.77</a>]</sup>.</p></li>
  <li><p><code>getResource()</code>:</p><p>Return a <code>URL</code> for the application resource mapped to the specified path, if it exists; otherwise, return <code>null</code>. This must be the value returned by the <code>javax.portlet.PortletContext</code> method <code>getResource(path)</code><sup>[<a href="TCK-Tests.html#6.78">6.78</a>]</sup>.</p></li>
  <li><p><code>getResourceAsStream()</code>:</p><p>Return an <code>InputStream</code> for an application resource mapped to the specified path, if it exists; otherwise, return <code>null</code>. This must be the value returned by the <code>javax.portlet.PortletContext</code> method <code>getResourceAsStream(path)</code><sup>[<a href="TCK-Tests.html#6.79">6.79</a>]</sup>.</p></li>
  <li><p><code>getResourcePaths()</code>:</p><p>Return the <code>Set</code> of resource paths for all application resources whose resource path starts with the specified argument. This must be the value returned by the <code>javax.portlet.PortletContext</code> method <code>getResourcePaths(path)</code><sup>[<a href="TCK-Tests.html#6.80">6.80</a>]</sup>.</p></li>
  <li><p><code>setResponseCharacterEncoding()</code>:</p><p>Sets the character encoding (MIME charset) of the response being sent to the client, for example, to UTF-8. This method must take no action<sup>[<a href="TCK-Tests.html#6.81">6.81</a>]</sup>.</p></li>
  <li><p><code>getSession()</code>:</p><p>If the <code>create</code> parameter is <code>true</code>, create (if necessary) and return a session instance associated with the current request. If the <code>create</code> parameter is <code>false</code> return any existing session instance associated with the current request, or return <code>null</code> if there is no such session. This method must return the result of calling <code>getPortletSession(create)</code> on the underlying <code>javax.portlet.PortletRequest</code> instance<sup>[<a href="TCK-Tests.html#6.82">6.82</a>]</sup>.</p></li>
  <li><p><code>getSessionMap()</code>: </p><p>Return a mutable <code>Map</code> representing the session (<code>PORTLET_SCOPE</code>) scope attributes for the current portlet<sup>[<a href="TCK-Tests.html#6.83">6.83</a>]</sup>. The returned <code>Map</code> must implement the entire contract for a modifiable map as described in the JavaDocs for <code>java.util.Map</code>. Modifications made in the Map must cause the corresponding changes in the set of session scope attributes. Particularly the <code>clear()</code>, <code>remove()</code>, <code>put()</code>, and <code>get()</code> operations must take the appropriate action on the underlying data structure. Accessing attributes via this <code>Map</code> must cause the creation of a session associated with the current request, if such a session does not already exist.</p><p>For any of the <code>Map</code> methods that cause an element to be removed from the underlying data structure, the following action regarding managed-beans must be taken. If the element to be removed is a managed-bean, and it has one or more public no-argument void return methods annotated with <code>javax.annotation.PreDestroy</code>, each such method must be called before the element is removed from the underlying data structure<sup>[<a href="TCK-Tests.html#6.84">6.84</a>]</sup>. Elements that are not managed-beans, but do happen to have methods with that annotation must not have those methods called on removal. Any exception thrown by the <code>PreDestroy</code> annotated methods must by caught and not rethrown. The exception may be logged.</p><p>This <code>Map</code> must be composed from the set of attributes that exist in the <code>PORTLET_SCOPE</code> available via the <code>javax.portlet.PortletSession</code> methods <code>getAttribute()</code>, <code>getAttributeNames()</code>, <code>removeAttribute()</code>, and <code>setAttribute()</code>.</p></li>
  <li><p><code>getUserPrincipal()</code>:</p><p>Return the <code>Principal</code> object containing the name of the current authenticated user, if any; otherwise, return <code>null</code>. This must be the value returned by the <code>javax.portlet.http.PortletRequest</code> method <code>getUserPrincipal()</code><sup>[<a href="TCK-Tests.html#6.85">6.85</a>]</sup>.</p></li>
  <li><p><code>isUserInRole()</code>:</p><p>Return <code>true</code> if the currently authenticated user is included in the specified role. Otherwise, return <code>false</code>. This must be the value returned by the <code>javax.portlet.http.PortletRequest</code> method <code>isUserInRole(role)</code>.</p></li>
  <li><p><code>log()</code>:</p><p>Log the specified message to the application object. This must be performed by calling the equivalent form of the <code>javax.portlet.PortletContext</code> method <code>log()</code>.</p></li>
</ul><a id="a-name62"></a><h2><a name="6.2"></a>6.2 ViewHandler</h2><p>The Faces <code>ViewHandler</code> is the pluggability mechanism that allows implementations to extend the JavaServer Faces specification to provide their own handling of the activities in the Render Response and Restore View phases of the request processing lifecycle. This allows for implementations to support different response generation technologies, as well as different state saving/restoring approaches.</p><p>The bridge is required to provide an implementation of the <code>ViewHandler</code><sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>. This implementation must be configured in the <code>faces-config.xml</code> file packaged into the bridge&rsquo;s <code>jar</code> file<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>. The implementation must implement the decorator design pattern described in section 10.4.5 in the JSF 1.2 specification<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>.</p><p>Because configuration is limited to using the <code>faces-config.xml</code> file packaged into the bridge&rsquo;s <code>jar</code> file, <code>ViewHandler</code> order can&rsquo;t be defined if other Faces extensions relying on the same <code>ViewHandler</code> configuration technique exist in the environment. The bridge implementation must safely cohabit with these other <code>ViewHandler</code>s regardless of precedence order in the particular runtime environment they execute in<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>. To satisfy this the bridge must delegate to its parent <code>ViewHandler</code> for all methods unless otherwise indicated to do so by a configuration parameter. For most methods this will be a strict delegation with no pre/post processing of the call. If pre/post processing is necessary it must be done in a manner that doesn&rsquo;t interfere with the normally processing of the other <code>ViewHandler</code>s in the chain. To facilitate this, implementations are encouraged to subclass <code>javax.faces.application.ViewHandlerWrapper</code>.</p><p>Furthermore, where ever the bridge provides bridge specific <code>ViewHandler</code> behavior, it must ensure this behavior is only executed when executing a request via the bridge<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>. Because the <code>ViewHandler</code> is a general Faces extension the bridge&rsquo;s <code>ViewHandler</code> methods will be called if the bridge is in this application&rsquo;s classpath regardless of whether the current request has been dispatched through the bridge.</p><a id="a-name621"></a><h3><a name="6.2.1"></a>6.2.1 Method Requirements</h3><p>The following <code>ViewHandler</code> methods must meet specific bridge requirements (i.e. have expected pre/post delegation processing):</p>
<ul>
  <li><p><code>createView()</code>: is responsible for returning the <code>UIViewRoot</code> for the newly created view tree. The bridge, during a portlet request, should return a <code>UIViewRoot</code> from its <code>createView()</code> that supports (is annotated by) <code>javax.portlet.faces.annotation.PortletNamingContainer</code>. Such a <code>NamingContainer</code> ensures all ids in the tree are unique on a per portlet (instance) basis <a href="Chapter-6-Bridge-Requirements-for-Managing-Faces.html#6.6">6.6</a>. This type of <code>UIViewRoot</code> must be returned unless the bridge delegates <code>UIViewRoot</code> creation and the result of that delegation is a <code>UIViewRoot</code> whose implementation class (not <code>instanceof</code>) is <strong>not</strong> <code>javax.faces.component.UIViewRoot</code><sup>[<a href="TCK-Tests.html#6.86">6.86</a>]</sup>.</p></li>
  <li><p><code>renderView()</code>: The bridge must implement <code>renderView</code> as follows: <pre></pre> If the request isn&rsquo;t a portlet request, delegate <code>renderView</code> to the parent and return the result without taking any further action. Otherwise<sup>[<a href="TCK-Tests.html#6.87">6.87</a>]</sup>: <pre></pre></p>
  <ul>
    <li><code>DEFAULT</code> behavior: return the result by delegating the call to its parent within a try/catch block that catches <code>Throwable</code>. If and only if a <code>Throwable</code> is caught, render the view directly accordingly to the rules described below.</li>
    <li><code>ALWAYS_DELEGATE</code> behavior: return the result by delegating the call to its parent regardless of whether the delegation results in raising a <code>Throwable</code>. I.e. never render the view accordingly to the rules described below.</li>
    <li><code>NEVER_DELEGATE</code> behavior: never delegate the call to its parent. Rather always render the view directly according to the rules described below. <pre></pre> Where <code>DEFAULT</code>, <code>ALWAYS_DELEGATE</code>, and <code>NEVER_DELEGATE</code> are the corresponding values of the per portlet bridge initialization attribute <code>renderPolicy</code> as described in <a href="Chapter-3-Bridge-Interface.html#3.2">3.2</a>. If no such setting exists <code>renderView</code> implements <code>DEFAULT</code> behavior.</li>
  </ul><p>When directly rendering the view, the bridge must render in a manner that provides the semantics defined by section 7.5.2 in the JSF 1.2 specification. Specifically it must attempt to ensure that it is possible for the markup generated by the view to be interleaved with native markup in a manner that preserves order as indicated in that section. Unfortunately, such interleaving can only be accomplished using Faces implementation dependent code and hence isn&rsquo;t provided natively by the bridge. Rather, the bridge defines mechanism(s) that allow a portlet to configure an appropriate render handler to support this behavior. There are two mechanisms [see <a href="Chapter-7-BridgeRenderFilter.html">Chapter 7</a>]:</p>
  <ol>
    <li>the portlet 1.0 bridge mechanism that relied on configuring a servlet filter that wraps the response with a wrapper that supports the Faces implementation specific APIs for handling the JSP write before/after response behavior.</li>
    <li>provide a Portlet 2.0 PortletResponseWrapper which supports the same APIs.</li>
  </ol><p>To support these mechanisms, the bridge&rsquo;s <code>render()</code>, prior to calling <code>dispatch()</code> must:</p>
  <ul>
    <li>Add an attribute named <code>javax.portlet.faces.RenderContentAfterView</code> with a <code>java.lang.Boolean</code> value of <code>Boolean.TRUE</code> to the <code>request</code> object<sup>[<a href="TCK-Tests.html#6.88">6.88</a>]</sup>.</li>
    <li>Cache the current response (known to the Faces <code>ExternalContext</code>) so it can be reset later.</li>
    <li>Create an instance of a <code>PortletResponseWrapper</code> object that implements <code>javax.portlet.faces.BridgeWriteBehindResponse</code> and set it in the Faces <code>ExternalContext</code> by calling <code>ExternalContext.setResponse()</code><sup>[<a href="TCK-Tests.html#6.132">6.132</a>]</sup> <pre></pre> If an instance class is configured [see <a href="Chapter-7-BridgeRenderFilter.html#7.2">7.2</a>], it must be used<sup>[<a href="TCK-Tests.html#6.133">6.133</a>, <a href="TCK-Tests.html#6.134">6.134</a>]</sup>.</li>
  </ul><p>Immediately following the <code>dispatch()</code>:</p>
  <ul>
    <li>Reset the Faces <code>ExternalContext</code> response by calling <code>ExternalContext.setResponse()</code> with the (current) response cached in the step above.</li>
    <li>If the <code>BridgeWriteBehindResponse</code> object&rsquo;s <code>hasFacesWriteBehindMarkup()</code> method returns <code>true</code> and something (servlet filter) hasn&rsquo;t already set the <code>javax.portlet.faces.AfterViewContent</code> attribute, support the write behind behavior by holding onto the <code>BridgeWriteBehindResponse</code> object or the content it is buffering until after the view has been rendered. Otherwise write the content directly to the response.</li>
  </ul><p>After the dispatch and after rendering the view (when one hasn&rsquo;t already written the content directly to the response):</p>
  <ul>
    <li>retrieve buffered content that should be positioned after the rendered view from the request attribute <code>javax.portlet.faces.AfterViewContent</code> (via a call to <code>ExternalContext.getRequestMap()</code>). If non-null, the type of this value is either <code>byte[]</code> or a <code>char[]</code>.</li>
    <li>If non-null, copy the content into the response and remove the attribute from the request <code>Map</code><sup>[<a href="TCK-Tests.html#6.89">6.89</a>]</sup>.</li>
    <li>(otherwise) if a <code>BridgeWriteBehindResponse</code> has been used and your bridge implementation doesn&rsquo;t rely on this request attribute to cache the content until after the view is rendered, output its buffered content.</li>
  </ul></li>
</ul><a id="a-name622"></a><h3><a name="6.2.2"></a>6.2.2 Other Methods</h3><p>The following <code>ViewHandler</code> methods have no specific bridge requirements and hence its expected they will always be delegated. If a bridge implementation does more then merely delegate if must satisfy the above cohabitation requirements. This is particularly true for <code>writeState</code> as overriding this commonly interferes with the application developers desired state management. If <code>getActionURL</code> is modified the bridge must ensure the resulting <code>String</code> it returns is a valid <code>URL</code>. In particular it can&rsquo;t be an <code>URL</code> derived from a <code>portletResponse.createActionURL()</code>.</p>
<ul>
  <li><code>calculateCharacterEncoding()</code></li>
  <li><code>calculateLocale()</code></li>
  <li><code>calculateRenderKitId()</code></li>
  <li><code>getActionURL()</code></li>
  <li><code>getResourceURL()</code></li>
  <li><code>initView()</code></li>
  <li><code>restoreView()</code></li>
  <li><code>writeState()</code></li>
</ul><a id="a-name63"></a><h2><a name="6.3"></a>6.3 StateManager</h2><p>To properly maintain references to (updated) view state the bridge will likely have to provide its own <code>StateManager</code> in order to override the state writing process allowing it to inspect and preserve (update) the value of the <code>VIEW_STATE_PARAM</code> parameter it manages in its extended bridge scope [<a href="Chapter-5-Bridge-Lifecycle-Requirements.html#5.1.2.2">5.1.2.2</a>]. For example the bridge can override <code>StateManager.writeState(FacesContext
context, Object state)</code>:</p>
<ul>
  <li>replace the <code>ResponseWriter</code> with one it manufactures that writes to a <code>StringWriter</code></li>
  <li>delegate the call so the state is output.</li>
  <li>copy the output back into the original <code>ResponseWriter</code></li>
  <li>parse the output in the <code>StringWriter</code> locating the <code>VIEW_STATE_PARAM</code> parameter and value</li>
  <li>copy the value and place it on a request attribute for the bridge to process later</li>
</ul><a id="a-name64"></a><h2><a name="6.4"></a>6.4 Phase Listeners</h2><p>The bridge must prevent the Faces action phases (<code>ApplyRequestValues</code>, <code>ProcessValidations</code>, <code>UpdateModel</code>, and <code>InvokeApplication</code>) from executing if processing an event or rendering in a restored bridge request scope<sup>[<a href="TCK-Tests.html#6.90">6.90</a>]</sup> [<a href="Chapter-5-Bridge-Lifecycle-Requirements.html#5.1.2">5.1.2</a>]. I.e. during either a portlet&rsquo;s <code>EVENT_PHASE</code> or <code>RENDER_PHASE</code>, when the Faces <code>Lifecycle</code> is executed to restore the view, the bridge must ensure the lifecycle falls directly through to render after the view is restored. This is most conveniently supported by implementing a <code>PhaseListener</code> and calling <code>FacesContext.renderResponse()</code> when invoked in the <code>RestoreView</code> phase.</p><a id="a-name65"></a><h2><a name="6.5"></a>6.5 Expression Language Resolution</h2><p>Faces relies on the Unified Expression Language architecture to ensure consistent EL evaluation in a JSP page where JSP expressions and Faces expressions can coexist. During a JSP EL resolution Faces extends the JSP resolvers to process/expose Faces unique variables. During a Faces EL resolution Faces provides the base resolvers that not only expose the Faces unique variables but also those that the JSP resolvers otherwise have access to during the scope of the page. In a servlet environment, this ensures evaluation consistency for the same expression whether within a JSP expression or a Faces expression. However because the EL types are resolved by different resolvers in different contexts when running in a portlet environment evaluation isn&rsquo;t always consistent. Its important to be aware of the following subtle differences in implicit object evaluation.</p><a id="a-name651"></a><h3><a name="6.5.1"></a>6.5.1 Implicit Objects</h3><p>When running in a JSP context, JSP provides an ELResolver that recognizes and resolves the following implicit objects<sup>[<a href="TCK-Tests.html#6.100">6.100</a>]</sup>:</p>
<ul>
  <li><code>applicationScope</code> -&gt; a <code>Map</code> that maps application-scoped attribute names to their values</li>
  <li><code>cookie</code> -&gt; a <code>Map</code> that maps cookie names to a single <code>Cookie</code> object. Cookies are retrieved according to the semantics of <code>HttpServletRequest.getCookies()</code>.</li>
  <li><code>header</code> -&gt; a <code>Map</code> that maps header names to a single <code>String</code> header value (obtained by calling <code>HttpServletRequest.getHeader(String name)</code>)</li>
  <li><code>headerValues</code> -&gt; a <code>Map</code> that maps header names to a <code>String[]</code> of all values for that header (obtained by calling <code>HttpServletRequest.getHeaders(String)</code>)</li>
  <li><code>initParam</code> -&gt; a <code>Map</code> that maps context initialization parameter names to their <code>String</code> parameter value (obtained by calling <code>ServletContext.getInitParameter(String name)</code>)</li>
  <li><code>pageContext</code> -&gt; the <code>PageContext</code></li>
  <li><code>pageScope</code> -&gt; a <code>Map</code> that maps page-scoped attribute names to their values</li>
  <li><code>param</code> -&gt; a <code>Map</code> that maps parameter names to a single <code>String</code> parameter value (obtained by calling <code>ServletRequest.getParameter(String name)</code>)</li>
  <li><code>paramValues</code> -&gt; <code>Map</code> that maps parameter names to a <code>String[]</code> of all values for that parameter (obtained by calling <code>ServletRequest.getParameterValues(String name)</code>)</li>
  <li><code>requestScope</code> -&gt; a <code>Map</code> that maps request-scoped attribute names to their values</li>
  <li><code>sessionScope</code> -&gt; a <code>Map</code> that maps session-scoped attribute names to their values</li>
</ul><p>When the <code>&lt;portlet:defineObjects&gt;</code> tag is used within this JSP page, the following variables are exposed and will be implicitly resolved by this JSP EL resolver<sup>[<a href="TCK-Tests.html#6.100">6.100</a>]</sup>:</p>
<ul>
  <li><code>portletConfig</code>: object of type <code>javax.portlet.PortletConfig</code></li>
  <li><code>actionRequest</code>: object of type <code>javax.portlet.ActionRequest</code> (only accessible in an <code>ActionRequest</code>)</li>
  <li><code>actionResponse</code>: object of type <code>javax.portlet.ActionResponse</code> (only accessible in an <code>ActionRequest</code>)</li>
  <li><code>eventRequest</code>: object of type <code>javax.portlet.EventRequest</code> (only accessible in an <code>EventRequest</code>)</li>
  <li><code>eventResponse</code>: object of type <code>javax.portlet.EventResponse</code> (only accessible in an <code>EventRequest</code>)</li>
  <li><code>renderRequest</code>: object of type <code>javax.portlet.RenderRequest</code> (only accessible in an <code>RenderRequest</code>)</li>
  <li><code>renderResponse</code>: object of type <code>javax.portlet.RenderResponse</code> (only accessible in an <code>RenderRequest</code>)</li>
  <li><code>resourceRequest</code>: object of type <code>javax.portlet.ResourceRequest</code> (only accessible in an <code>ResourceRequest</code>)</li>
  <li><code>resourceResponse</code>: object of type <code>javax.portlet.ResourceResponse</code> (only accessible in an <code>ResourceRequest</code>)</li>
  <li><code>portletSession</code>: current <code>PortletSession</code> object.</li>
  <li><code>portletSessionScope</code>: immutable <code>Map</code> containing <code>PortletSession</code> attribute/values at <code>PORTLET_SCOPE</code>.</li>
  <li><code>portletPreferences</code>: current <code>PortletPreferences</code> object.</li>
  <li><code>portletPreferencesValues</code>: immutable <code>Map</code> containing entries equivalent to <code>PortletPreferences.getMap()</code>.</li>
</ul><p>Faces extends this behavior by providing its own ELResolver to recognize and resolve the following implicit objects<sup>[<a href="TCK-Tests.html#6.100">6.100</a>]</sup>:</p>
<ul>
  <li><code>facesContext</code> -&gt; the <code>FacesContext</code> for this request</li>
  <li><code>view</code> -&gt; <code>facesContext.getViewRoot()</code></li>
</ul><p>When running in a Faces context (outside of JSP execution) Faces provides the base implicit object resolver that recognizes and resolves the following implicit objects[6.101]:</p>
<ul>
  <li><code>application</code> -&gt; <code>externalContext.getContext()</code></li>
  <li><code>applicationScope</code> -&gt; <code>externalContext.getApplicationMap()</code></li>
  <li><code>cookie</code> -&gt; <code>externalContext.getRequestCookieMap()</code></li>
  <li><code>facesContext</code> -&gt; the <code>FacesContext</code> for this request</li>
  <li><code>header</code> -&gt; <code>externalContext.getRequestHeaderMap()</code></li>
  <li><code>headerValues</code> -&gt; <code>externalContext.getRequestHeaderValuesMap()</code></li>
  <li><code>initParam</code> -&gt; <code>externalContext.getInitParameterMap()</code></li>
  <li><code>param</code> -&gt; <code>externalContext.getRequestParameterMap()</code></li>
  <li><code>paramValues</code> -&gt; <code>externalContext.getRequestParameterValuesMap()</code></li>
  <li><code>request</code> -&gt; <code>externalContext.getRequest()</code></li>
  <li><code>requestScope</code> -&gt; <code>externalContext.getRequestScope()</code></li>
  <li><code>session</code> -&gt; <code>externalContext.getSession()</code></li>
  <li><code>sessionScope</code> -&gt; <code>externalContext.getSessionMap()</code></li>
  <li><code>view</code> -&gt; <code>facesContext.getViewRoot()</code></li>
</ul><p>The primary difference between the <code>ELResolvers</code> used within the <code>JSP</code> context vs outside this context is that the base <code>JSP ELResolver</code> is used to resolve the bulk of the implicit objects and that this resolution is based on the <code>JSP</code>s servlet objects in the page while outside this context these objects are resolved via the <code>ExternalContext</code>. In a portlet environment, because the <code>JSP
ELResolver</code> evaluates based on the servlet objects generated when dispatched from the portlet environment while the <code>JSF ELResolver</code> evaluates based on the <code>ExternalContext</code>, the following difference needs to be considered:</p>
<ul>
  <li><code>sessionScope</code>: This <code>Map</code> contains the <code>APPLICATION_SCOPE</code> session attributes if used in JSP EL but <code>PORTLET_SCOPE</code> session attributes if used in Faces EL<sup>[<a href="TCK-Tests.html#6.100">6.100</a>,<a href="TCK-Tests.html#6.101">6.101</a>]</sup>.</li>
</ul><p>In addition one will note that the Faces implicit object ELResolver recognizes three objects that the JSP Resolver doesn&rsquo;t<sup>[<a href="TCK-Tests.html#6.101">6.101</a>]</sup>:</p>
<ul>
  <li><code>application</code></li>
  <li><code>session</code></li>
  <li><code>request</code></li>
</ul><p>In a JSP ELContext one references these objects indirectly via the PageContext<sup>[<a href="TCK-Tests.html#6.100">6.100</a>]</sup>. I.e.</p>
<ul>
  <li><code>${pageContext.servletContext}</code></li>
  <li><code>${pageContext.session}</code></li>
  <li><code>${pageContext.request}</code></li>
</ul><p>These differ from the objects returned by the Faces EL Resolver in that<sup>[<a href="TCK-Tests.html#6.101">6.101</a>]</sup>:</p>
<ul>
  <li><code>${pageContext.servletContext}</code>: This is an object of type <code>ServletContext</code> while application is an object of type <code>PortletContext</code>.</li>
  <li><code>${pageContext.session}</code>: This is an object of type servlet <code>Session</code> while <code>session</code> is an object of type <code>PortletSession</code>. The key difference is that <code>PortletSession</code> by default references <code>PORTLET_SCOPE</code> attributes while the servlet <code>Session</code> is a window onto the portlet&rsquo;s <code>APPLICATION_SCOPE</code>.</li>
  <li><code>${pageContext.request}</code>: This is an object of type <code>ServletRequest</code> (through wrapped by the portlet request) while <code>request</code> is an object of type <code>PortletRequest</code>.</li>
</ul><a id="a-name652"></a><h3><a name="6.5.2"></a>6.5.2 Bridge ELResolver</h3><p>As noted above, when the <code>&lt;portlet:defineObjects&gt;</code> tag is used, the following variables are exposed in the JSP page and will be implicitly resolved by the JSP EL resolver<sup>[<a href="TCK-Tests.html#6.100">6.100</a>]</sup>:</p>
<ul>
  <li><code>portletConfig</code>: object of type <code>javax.portlet.PortletConfig</code></li>
  <li><code>actionRequest</code>: object of type <code>javax.portlet.ActionRequest</code> (only accessible in an <code>ActionRequest</code>)</li>
  <li><code>actionResponse</code>: object of type <code>javax.portlet.ActionResponse</code> (only accessible in an <code>ActionRequest</code>)</li>
  <li><code>eventRequest</code>: object of type <code>javax.portlet.EventRequest</code> (only accessible in an <code>EventRequest</code>)</li>
  <li><code>eventResponse</code>: object of type <code>javax.portlet.EventResponse</code> (only accessible in an <code>EventRequest</code>)</li>
  <li><code>renderRequest</code>: object of type <code>javax.portlet.RenderRequest</code> (only accessible in an <code>RenderRequest</code>)</li>
  <li><code>renderResponse</code>: object of type <code>javax.portlet.RenderResponse</code> (only accessible in an <code>RenderRequest</code>)</li>
  <li><code>resourceRequest</code>: object of type <code>javax.portlet.ResourceRequest</code> (only accessible in an <code>ResourceRequest</code>)</li>
  <li><code>resourceResponse</code>: object of type <code>javax.portlet.ResourceResponse</code> (only accessible in an <code>ResourceRequest</code>)</li>
  <li><code>portletSession</code>: current <code>PortletSession</code> object.</li>
  <li><code>portletSessionScope</code>: immutable <code>Map</code> containing <code>PortletSession</code> attribute/values at <code>PORTLET_SCOPE</code>.</li>
  <li><code>portletPreferences</code>: current <code>PortletPreferences</code> object.</li>
  <li><code>portletPreferencesValues</code>: immutable <code>Map</code> containing entries equivalent to <code>PortletPreferences.getMap()</code>.</li>
</ul><p>The bridge must provide a corresponding Faces EL resolver that recognizes these variable names and resolves them to the same object as the JSP resolver<sup>[<a href="TCK-Tests.html#6.101">6.101</a>]</sup>. In addition, the bridge must not resolve these variables outside of a Faces expression<sup>[<a href="TCK-Tests.html#6.100">6.100</a>]</sup>. Note: The mechanism Faces provides for registering a EL resolver causes the EL resolver to be inserted into the resolution chain for both Faces expressions and JSP expressions. For the above objects, the bridge&rsquo;s EL resolver must delegate resolution to the JSP resolver within JSP expressions while resolving them within Faces expressions.</p><p>Because JSP EL evaluation and Faces EL evaluation are handled by different resolvers, the following differences are noted:</p>
<ul>
  <li><code>portletSessionScope</code>: This is an immutable <code>Map</code> when referenced in a JSP expression but a mutable <code>Map</code> when referenced in a Faces expression.</li>
</ul><a id="a-name6521"></a><h4><a name="6.5.2.1"></a>6.5.2.1 Additional Implicit Object Support for Portlets</h4><p>The bridge&rsquo;s ELResolver must additionally recognize and resolve identically the following EL object references regardless of whether its evaluating in a JSP or Faces expression<sup>[<a href="TCK-Tests.html#6.100">6.100</a>,<a href="TCK-Tests.html#6.101">6.101</a>]</sup>:</p>
<ul>
  <li><code>httpSessionScope</code>: mutable <code>Map</code> containing <code>PortletSession</code> attribute/values at <code>APPLICATION_SCOPE</code>.</li>
  <li><code>mutablePortletPreferencesValues</code>: mutable <code>Map</code> of type <code>Map&lt;String,
javax.portlet.faces.preference.Preference&gt;</code>. This EL variable provides read/write access to each portlet preference.</li>
</ul><a id="a-name6522"></a><h4><a name="6.5.2.2"></a>6.5.2.2 ELResolver Requirements</h4><p>The bridge&rsquo;s ELResolver must be added through configuration within its faces-config.xml. e.g.</p>
<pre><code>&lt;el-resolver&gt;
    javax.portlet.faces.el.PortletELResolver
&lt;/el-resolver&gt;
</code></pre><p>The ELResolver must be implemented as follows<sup>[<a href="TCK-Tests.html#6.100">6.100</a>,<a href="TCK-Tests.html#6.101">6.101</a>]</sup>:</p><p>ELResolver method implementation requirements getValue If running in a non-portlet request or base is non-null return null. If evaluating a JSP expression (nonFaces expression) and property is either portletConfig, renderRequest, or renderResponse, return null. If base is null and property is null, throw PropertyNotFoundException. If none of the above and base is null and property is a String equal to one of the above names, call setPropertyResolved(true) on the argument ELContext and return result, where property and result are as follows:</p>
<!--HTML Table-->
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td><span style="font-weight: bold;">ELResolver
method</span></td>
<td style="vertical-align: bottom;"><span style="font-weight: bold;">implementation requirements</span></td>
</tr>
<tr>
<td style="text-align: left; vertical-align: top;"><span style="font-family: monospace;">getValue</span></td>
<td>If running in a non-portlet request or base is non-null
return <span style="font-family: monospace;">null</span>.<br>
If evaluating a JSP expression (nonFaces expression) and property is
either <span style="font-family: monospace;">portletConfig</span>,
<span style="font-family: monospace;">renderRequest</span>,
or <span style="font-family: monospace;">renderResponse</span>,
return <span style="font-family: monospace;">null</span>.<br>
If base is null and property is null, throw PropertyNotFoundException.<br>
If none of the above and base is null and property is a String equal to
one of the above
names, call setPropertyResolved(true) on<br>
the argument ELContext and return result, where property and
result are as follows:<br>
<div style="margin-left: 40px;"><span style="font-style: italic;"><br>
</span><span style="font-family: monospace;"></span><span style="color: rgb(51, 51, 255);"></span><span style="font-family: monospace;"></span><br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td style="text-align: center;"><span style="font-style: italic;">EL object name</span></td>
<td style="text-align: center;"><span style="font-style: italic;">result</span></td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">portletConfig</span></td>
<td><span style="font-family: monospace; color: rgb(0, 0, 0);">portletConfig
object (recommended implementation is to place the portletConfig object
on the
ELContext so can pull it here).</span></td>
</tr>
<tr>
<td><span style="font-family: monospace;">actionRequest</span></td>
<td>If within an <span style="font-family: monospace;">ActionRequest</span>
then <span style="font-family: monospace;">ExternalContext.getRequest()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span>.</td>
</tr>
<tr>
<td style="font-family: monospace;">actionResponse</td>
<td>If within an <span style="font-family: monospace;">ActionRequest</span>
then&nbsp;<span style="font-family: monospace;">ExternalContext.getResponse()
</span>otherwise throw an <span style="font-family: monospace;">ELException</span>.</td>
</tr>
<tr>
<td style="font-family: monospace;">eventRequest</td>
<td>If within an <span style="font-family: monospace;">EventRequest</span>
then <span style="font-family: monospace;">ExternalContext.getRequest()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span>.</td>
</tr>
<tr>
<td style="font-family: monospace;">eventResponse</td>
<td>If within an <span style="font-family: monospace;">EventRequest</span>
then&nbsp;<span style="font-family: monospace;">ExternalContext.getResponse()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span>.</td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">renderRequest</span></td>
<td>If within an <span style="font-family: monospace;">RenderRequest</span>
then <span style="font-family: monospace;">ExternalContext.getRequest()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span><span style="font-family: monospace;"></span></td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">renderResponse</span></td>
<td>If within an <span style="font-family: monospace;">RenderRequest</span>
then&nbsp;<span style="font-family: monospace;">ExternalContext.getResponse()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span>.<span style="font-family: monospace;"></span></td>
</tr>
<tr>
<td style="font-family: monospace;">resourceRequest</td>
<td>If within an <span style="font-family: monospace;">ResourceRequest</span>
then <span style="font-family: monospace;">ExternalContext.getRequest()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span>.</td>
</tr>
<tr>
<td style="font-family: monospace;">resourceResponse</td>
<td>If within an <span style="font-family: monospace;">ResourceRequest</span>
then&nbsp;<span style="font-family: monospace;">ExternalContext.getResponse()</span>
otherwise throw an <span style="font-family: monospace;">ELException</span>.</td>
</tr>
<tr>
<td><span style="font-family: monospace;">portletSession</span></td>
<td><span style="font-family: monospace;">ExternalContext.getSession()</span></td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">portletSessionScope</span></td>
<td><span style="font-family: monospace;">ExternalContext.getSessionMap()</span></td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">httpSessionScope</span></td>
<td><span style="font-family: monospace;">an
internally constructed Map containing those portlet session attributes
at APPLICATION_SCOPE</span><span style="font-family: monospace;">.</span></td>
</tr>
<tr>
<td><span style="font-family: monospace;">portletPreferences</span></td>
<td><span style="font-family: monospace;">ExternalContext.getRequest()).getPreferences()</span></td>
</tr>
<tr>
<td><span style="font-family: monospace;">portletPreferencesValues</span></td>
<td><span style="font-family: monospace;">ExternalContext.getRequest()).getPreferences().getMap()</span></td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0);"><span style="font-family: monospace;">mutablePortletPreferencesValues</span></td>
<td style="color: rgb(0, 0, 0);"><span style="font-family: monospace;">An
internally constructed Map &lt;String,
javax.portlet.faces.preference.Preference&gt;. There is one entry
per portlet preference. The key is the preference
name. &nbsp;The value is an object representing a single portlet
preference
(as defined by this interface). Entries may not be added or deleted
but and entry can be changed.</span></td>
</tr>
</tbody>
</table>
<span style="font-family: monospace; color: rgb(0, 0, 0);"></span><span style="font-family: monospace; color: rgb(51, 51, 255);"><br>
</span><span style="font-family: monospace;"><span style="color: rgb(0, 0, 0);"></span> </span></div>
<br>
If base is null, and property does not match one of the above property
names, return null.</td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">getType</span></td>
<td>If running in a non-portlet request or base is
non-null, return null.<br>
If base is null and property is null, throw <span style="font-family: monospace;">PropertyNotFoundException</span>.<br>
If base is null and property is a String equal to any of the above
names, call setPropertyResolved(true) on the argument ELContext and
return null to indicate that no types are accepted to setValue() for
these attributes.<br>
Otherwise, null;</td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">setValue</span></td>
<td>If running in a non-portlet request or base is
non-null, return null.<br>
If base is null and property is null, throw <span style="font-family: monospace;">PropertyNotFoundException</span>.<br>
If base is null and property is a String equal to any of the above
names throw <span style="font-family: monospace;">javax.el.PropertyNotWriteableException</span>,
since these&nbsp;objects are read-only.</td>
</tr>
<tr>
<td style="vertical-align: top;"><span style="font-family: monospace;">isReadOnly</span></td>
<td>If running in a non-portlet request or base is
non-null, return null.<br>
If base is null and property is null, throw <span style="font-family: monospace;">PropertyNotFoundException</span>.<br>
If base is null and property is a String equal to any of the above
names call <span style="font-family: monospace;">setPropertyResolved(true)</span>
on the argument ELContext and return true.</td>
</tr>
<tr>
<td style="color: rgb(51, 51, 255);"><br>
<span style="color: rgb(0, 0, 0);">getFeatureDescriptors</span></td>
<td style="color: rgb(51, 51, 255);"><span style="color: rgb(0, 0, 0);">If base is
non-null, return null.</span><br style="color: rgb(0, 0, 0);">
<span style="color: rgb(0, 0, 0);">If base is null,
return an Iterator containing
java.beans.FeatureDescriptor instances, one for each of the above
names. It is required that all of these FeatureDescriptor instances set
Boolean.TRUE as the value of the ELResolver.RESOLVABLE_AT_DESIGN_TIME
attribute. For the name and short of FeatureDescriptor, return the EL
object name. The appropriate Class must be stored as the value
of the ELResolver.TYPE attribute as follows:</span><br>
<table style="text-align: left; width: 658px; height: 200px;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td style="vertical-align: top; font-style: italic; text-align: center; color: rgb(0, 0, 0);">EL
object name</td>
<td style="vertical-align: top; font-style: italic; text-align: center; color: rgb(0, 0, 0);">ELResolver.TYPE
value</td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">portletConfig</td>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">javax.portlet.PortletConfig.class</td>
</tr>
<tr>
<td style="font-family: monospace;">actionRequest</td>
<td style="font-family: monospace;">javax.portlet.ActionRequest.class</td>
</tr>
<tr>
<td style="font-family: monospace;">actionResponse</td>
<td style="font-family: monospace;">javax.portlet.ActionResponse.class</td>
</tr>
<tr>
<td style="font-family: monospace;">eventRequest</td>
<td style="font-family: monospace;">javax.portlet.EventRequest.class</td>
</tr>
<tr>
<td style="font-family: monospace;">eventResponse</td>
<td style="font-family: monospace;">javax.portlet.EventResponse.class</td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">renderRequest</td>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">javax.portlet.RenderRequest.class</td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">renderResponse</td>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">javax.portlet.RenderResponse.class</td>
</tr>
<tr>
<td style="font-family: monospace;">resourceRequest</td>
<td style="font-family: monospace;">javax.portlet.ResourceRequest.class</td>
</tr>
<tr>
<td style="font-family: monospace;">resourceResponse</td>
<td style="font-family: monospace;">javax.portlet.ResourceResponse.class</td>
</tr>
<tr>
<td><span style="font-family: monospace;">portletSession</span></td>
<td style="font-family: monospace;">javax.portlet.PortletSession.class</td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">portletSessionScope</td>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">Map.class</td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">httpSessionScope</td>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">Map.class</td>
</tr>
<tr>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">portletPreferences</td>
<td style="vertical-align: top; color: rgb(0, 0, 0); font-family: monospace;">javax.portlet.PortletPreferences.class<br>
</td>
</tr>
<tr>
<td style="font-family: monospace;">portletPreferencesValues</td>
<td style="font-family: monospace;">Map.class</td>
</tr>
<tr>
<td style="font-family: monospace;">mutablePortletPreferencesValues</td>
<td style="font-family: monospace;">Map.class</td>
</tr>
</tbody>
</table>
<br>
&nbsp;<br>
<span style="color: rgb(0, 0, 0);">The
shortDescription must be a suitable description depending on the
implementation. The expert and hidden properties must be false. The
preferred property must be true.</span></td>
</tr>
<tr>
<td style="color: rgb(51, 51, 255);"><span style="color: rgb(0, 0, 0);">getCommonPropertyType</span><br>
</td>
<td style="color: rgb(0, 0, 0);">If base is
non-null, return null.<br>
If base is null and return String.class</td>
</tr>
</tbody>
</table><a id="a-name6523"></a><h4><a name="6.5.2.3"></a>6.5.2.3 The javax.portlet.faces.preference.Preference interface</h4><p>The mutablePortletPreferencesValues EL object allows one to read and update a portlet preference via EL. It relies on the bridge defined <code>javax.portlet.faces.preference.Preference</code> interface which allows one to expose each portlet preference as an individual object making operations on portlet preferences EL accessible. Consult the <code>javax.portlet.faces.preference.Preference</code> javadoc for specific descriptions and requirements of objects implementing this interface. In general there is a corresponding method for each operation in <code>javax.portlet.Preferences</code> that can be done on a specific preference. For example, a preference named &ldquo;title&rdquo; managed by the <code>javax.portlet.Preferences</code> object could have its value accessed using its corresponding <code>javax.portlet.faces.preference.Preference</code> instance via <code>title.PrefObj.getValue()</code> rather than the typical <code>preferences.getValue(&quot;title&quot;)</code>. Equivalent EL access would be: &quot;<code>#{mutablePortletPreferencesValues[&#39;title&#39;].value&quot;</code>.</p><p>Though operations performed on <code>javax.portlet.faces.preference.Preference</code> objects are immediately passed through to the underlying <code>portletPreferences</code> object, because the <code>portletPreferences</code> object requires an explicit commit to preserve these changes, developers must take care to finalize changes by calling <code>portletPreferences.store()</code> directly before the request ends. Typically this is done in the clients <code>ActionHandler</code> executed during the <code>InvokeApplication</code> phase.</p><a id="a-name66"></a><h2><a name="6.6"></a>6.6 Namespacing</h2><p>Portlets are components that are aggregated by another application into a response page. As such a portlet is responsible for namespacing its markup to ensure its names don&rsquo;t collide with other parts of the aggregated page even when that aggregated page contains additional instances of this portlet. Traditionally, because the Java Portlet standard assumes the aggregated page isolates each portlet in a manner that allows discrete forms, namespacing is only required for global names such as javascript functions and variables. Unfortunately, many of today&rsquo;s Faces renderkits rely on this type of client side javascript necessitating namespacing when run in the portlet environment.</p><p>Additionally, with the emergence of consumer environments based on JSF and .NET in which such forms are collapsed into a a single all encompassing page form, the issue of namespacing form fields has emerged. Though from the standards perspective such consumers still have the burden of parsing and transforming the portlet markup to work in the single form environment, the ability for consumers to do this is restricted by both its needs to return a response to the user quickly and the complexity of locating (javascript) references to field names. Portlets, therefore, though not required, are encouraged to namespace not only their global (client) references but also their form fields as well.</p><p>Faces supports a notion of namespacing elements in its view tree which in turn impacts form field names and renderkit resources such as its javascript names. A namespace is introduced using a concept called a <code>NamingContainer</code>. When Faces needs to construct a name it ascends the view tree looking for the closest parent that implements <code>NamingContainer</code>. If it finds one this parent gets an opportunity to return a namespace that will be incorporated into the name.</p><p>Though structurally supportive, Faces however doesn&rsquo;t inherently provide proper portlet namespacing. The bridge needs to introduce this support. This is done by returning a <code>UIViewRoot</code> from <code>ViewHandler.createView()</code> that implements <code>NamingContainer</code> in a manner whereby the generated container name is constructed in part by using the unique namespace <code>Id</code> of the portlet. More specifically, a <code>UIViewRoot</code> with the <code>javax.portlet.faces.annotation.PortletNamingContainer</code> annotation must implement <code>getContainerClientId()</code> to return a <code>String</code> containing (at least in part) the portlet&rsquo;s namespace <code>Id</code>, if and only if, called during a portlet request<sup>[<a href="TCK-Tests.html#6.91">6.91</a>]</sup>. The namespace Id used in processing <code>getContainerClientId()</code> must be consistent for the lifetime of the view (across save and restore)<sup>[<a href="TCK-Tests.html#6.92">6.92</a>]</sup>. Because getContainerClientId() can be called during any portlet lifecycle phase (action or render)<sup>[<a href="TCK-Tests.html#6.93">6.93</a>]</sup>, care should be taken in implementing this support to ensure such consistency as Portlet 1.0 containers only expose the portlet&rsquo;s namespace <code>Id</code> during the render phase and hence <code>ExternalContext.encodeNamespace()</code> throws an exception if called during a portlet action request.</p><p>The convenience class <code>javax.portlet.faces.PortletNamingContainerUIViewRoot</code><sup>[<a href="TCK-Tests.html#6.94">6.94</a>]</sup> is provided to simplify adding portlet namespacing for Faces extensions (and for internal bridge usage). This class can either be used directly or subclassed. The class is annotated with the <code>javax.portlet.faces.annotation.PortletNamingContainer</code> annotation<sup>[<a href="TCK-Tests.html#6.95">6.95</a>]</sup> ensuring the bridge will recognize this <code>UIViewRoot</code> as one that implements the portlet namespacing behavior. It implements <code>getContainerClientId()</code> to meet the above requirements<sup>[<a href="TCK-Tests.html#6.96">6.96</a>]</sup>. In addition its returns <code>getContainerClientId()null</code> for non-portlet requests. This ensures the class can be used by the bridge as a replacement for the standard <code>javax.faces.component.UIViewRoot</code> because it ensures that non-portlet behavior runs unchanged, without <code>NamingContainer</code> function.</p><p>As indicated, annotating the <code>UIViewRoot</code> class with <code>javax.portlet.faces.annotation.PortletNamingContainer</code> allows the bridge&rsquo;s <code>FacesContext</code> to detect that the response will be portlet namespaced. To signal this behavior to the consumer, <code>FacesContext.setViewRoot()</code> sets the &ldquo;<code>X-JAVAX-PORTLET-FACES-NAMESPACED-RESPONSE</code>&rdquo; response property with a value of &ldquo;<code>true</code>&rdquo;<sup>[<a href="TCK-Tests.html#nt">nt</a>]</sup>. Consumers needing to do response parsing to meet its namespacing requirements (e.g. when inserting the response into a single overall page form) can use the existence of this property as an indication that the form fields in the portlet response have already been properly namespaced and hence need not be fixed up as part of the form parsing process.</p><a id="a-name67"></a><h2><a name="6.7"></a>6.7 Supporting isPostback() during RENDER_PHASE</h2><p>When rendering, Faces depends on distinguishing between renders that follow action processing within the same request and renders that do not. This is determined by calling <code>ResponseStateManager.isPostback()</code>. Because portlet renders occur in distinct requests from actions, the state Faces depends on to make this determination isn&rsquo;t naturally present. As discussed in section <a href="Chapter-5-Bridge-Lifecycle-Requirements.html#5.1.2">5.1.2</a> the bridge is required to ensure the existence and/or absence of such state within its render phase in order to ensure proper execution of <code>isPostback()</code>. Specifically, the bridge is required to always preserve the <code>ResponseStateManager.VIEW_STATE_PARAM</code> parameter in each bridge request scope. This is done at the at the end of the <code>ACTION_PHASE</code> and <code>EVENT_PHASE</code> phase. Furthermore it must restore this request parameter at the beginning of each <code>RENDER_PHASE</code> phase that corresponds to this bridge request scope such that a call to <code>ExternalContext.getRequestParameterMap().get(ResponseStateManager.VIEW_STATE_PARAM)</code> returns the restored value<sup>[<a href="TCK-Tests.html#6.97">6.97</a>]</sup>. Finally, when its able to restore this parameter the bridge must also set the request attribute <code>javax.portlet.faces.isPostback</code> with a <code>Boolean</code> object whose value is <code>Boolean.TRUE</code><sup>[<a href="TCK-Tests.html#6.98">6.98</a>]</sup>. This allows alternative <code>isPostback()</code> implementations that do not rely on the existence of the <code>ResponseStateManager.VIEW_STATE_PARAM</code> to recognize they are running in a postback situation.</p><a id="a-name68"></a><h2><a name="6.8"></a>6.8 Supporting PreDestroy Annotated Methods</h2><p>Faces requires that all managed beans be given the opportunity to clean themselves up when they are being removed from one of the three container scopes (application, session, request). The function is managed via annotations and injection. A managed bean with one or more public no-argument void return methods annotated with <code>javax.annotation.PreDestroy</code> will be called when either the object is removed from scope or the scope terminates.</p><p>When running in the bridge, the lifetime of the application and session scopes aren&rsquo;t modified but the request scope is. The bridge implements an extended request scope called the bridge request scope. This scope preserves managed beans across physical requests ensuring that applications written in a style where request scoped managed beans are used to maintain state between the Faces action and render lifecycles will function properly in the portlet&rsquo;s multi-request lifecycle. However, because bridge request scope data is transferred into the portlet request scope when processing a request, special handling is required by managed beans utilizing the annotation to avoid releasing the bean prematurely. This is because the bridge can&rsquo;t prevent the <code>PreDestroy</code> method from being called when the portlet request scope ends even though it is managing the attribute in its request scope. I.e. managed beans managed by the bridge in its bridge request scope will still be notified they are being destroyed at the end of each portlet request. To work properly clients must change their managed bean implementations for those beans not excluded from the bridge request scope and the bridge must provide new (additional) mechanisms.</p><a id="a-name681"></a><h3><a name="6.8.1"></a>6.8.1 Managed Bean Changes</h3><p>Managed beans that want to utilize <code>PreDestroy</code> and run properly when not explicitly excluded from the bridge request scope must:</p>
<ul>
  <li>Create separate but equal methods for handling the cleanup in the bridge environment. This distinct method(s) is identified by the <code>BridgePreDestroy</code> annotation (<code>javax.portlet.faces.annotation.BridgePreDestroy</code>).</li>
  <li>Add a new public no-argument void return method annotated with <code>BridgeRequestScopeAttributeAdded</code> (<code>javax.portlet.faces.annotation.BridgeRequestScopeAttributeAdded</code>). This method is called when the managed bean is added to the portlet request scope and it will be preserved by the bridge in the bridge request scope. When called a managed bean is expected to set internal state such that when its <code>PreDestroy</code> method(s) is called (later) it can check this state and if it indicates the request is running under the management of the bridge the <code>PreDestroy</code> returns without doing any cleanup. This mechanism works around the issues related to the bridge being unable to disable the execution of the <code>PreDestroy</code> method even when it continues to manage this bean in its request scope.</li>
  <li>Modify each method annotated with <code>PreDestroy</code> to check if its executing under bridge management and if so return without performing any cleanup.</li>
</ul><a id="a-name682"></a><h3><a name="6.8.2"></a>6.8.2 Bridge requirements</h3><p>To satisfy the Faces requirement that managed beans managed in the bridge&rsquo;s request scope have an opportunity to release themeselves when the bridge request scope ends, the bridge must provide the following once it has acquired a <code>FacesContext</code> for a given request:</p>
<ul>
  <li>When the bridge preserves a request attribute in the bridge request scope, the bridge must execute on the attribute&rsquo;s value all public no argument void return methods annotated by <code>BridgeRequestScopeAttributeAdded</code><sup>[<a href="TCK-Tests.html#nt">nt</a>/<a href="TCK-Tests.html#6.44">6.44</a>]</sup>.</li>
  <li>When an attribute that is currently maintained in the bridge&rsquo;s request scope is explicitly removed from the container&rsquo;s request scope or its value replaced, the bridge must execute on the (old) attribute&rsquo;s value any public no-argument void return method annotated by <code>BridgePreDestroy</code> if executing in the action phase<sup>[<a href="TCK-Tests.html#nt">nt</a>/<a href="TCK-Tests.html#6.44">6.44</a>]</sup>. Note: because the bridge request scope isn&rsquo;t updated during its render phase replace/removal of an attribute&rsquo;s value from the container&rsquo;s request scope must not cause the <code>BridgePreDestroy</code> method(s) to be called<sup>[<a href="TCK-Tests.html#nt">nt</a>/<a href="TCK-Tests.html#6.44">6.44</a>]</sup>.</li>
  <li>When an attribute that is currently maintained in the bridge&rsquo;s request scope is implicitly removed from the container&rsquo;s request scope (such as when the container&rsquo;s request scope ends), the bridge does not notify the attribute&rsquo;s <code>BridgePreDestroy</code> methods<sup>[<a href="TCK-Tests.html#nt">nt</a>/<a href="TCK-Tests.html#6.44">6.44</a>]</sup>. This is because the attribute is still managed in the bridge request scope though removed from the underlying container request scope which is terminating.</li>
  <li>When the bridge is terminating a bridge request scope, the bridge must iterate over all managed attributes and execute on the attribute&rsquo;s value any public no-argument void return method annotated by <code>BridgePreDestroy</code><sup>[<a href="TCK-Tests.html#nt">nt</a>/<a href="TCK-Tests.html#6.44">6.44</a>]</sup>.</li>
</ul><a id="a-name69"></a><h2><a name="6.9"></a>6.9 Setting the RenderKit used by a Portlet</h2><p>Faces resolves the renderkit used in a given request by first looking for a request parameter whose name is the value of <code>ResponseStateManager.RENDER_KIT_ID_PARAM</code>. If this parameter doesn&rsquo;t exist the id is next determined from a configuration parameter in the application&rsquo;s <code>faces-config.xml</code> and finally an internal setting. Given that the <code>faces-config.xml</code> is an application wide setting, the request parameter is the sole mechanism for managing the needs of portlets that use distinct renderkits. As this may not be uncommon and most portlets use the same renderkit throughout all its views, the bridge simplifies the use of this request parameter if the proper context attribute has been set prior to it being initialized.</p><p>Specifically, when the bridge is initialized, if the portlet context attribute <code>javax.portlet.faces.&lt;portletName&gt;.defaultRenderKitId</code> is set, the bridge is responsible for ensuring that in every request the request parameter <code>Map</code>(s) returned from <code>ExternalContext.getRequestParameterMap()</code> and <code>ExternalContext.getRequestParameterValuesMap()</code> and the <code>Iterator</code> returned from the <code>ExternalContext.getRequestParameterNames()</code> contain an entry for <code>ResponseStateManager.RENDER_KIT_ID_PARAM</code><sup>[<a href="TCK-Tests.html#6.135">6.135</a>]</sup>. In the <code>Map</code>(s), the value for this entry must be the value from the underlying request, if it exists, otherwise it must be the value in the <code>javax.portlet.faces.&lt;portletName&gt;.defaultRenderKitId</code> context attribute<sup>[<a href="TCK-Tests.html#6.135">6.135</a>]</sup>.</p><p><span style="font-weight: bold;"></span></span></div> <table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td>&nbsp; <a href="Chapter-5-Bridge-Lifecycle-Requirements.html">Previous</a></td> <td style="text-align: center;"><a href="TOC.html">Portlet 2.0 Bridge for JavaServer<small><sup>TM</sup></small>Faces 1.2 &ndash; November 14th, 2010</a></td> <td style="text-align: right;"><a href="Chapter-7-BridgeRenderFilter.html">Next</a> &nbsp;</td> </tr> </tbody> </table></p>
